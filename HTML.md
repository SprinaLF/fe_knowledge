## 关于http，最全

https://www.cnblogs.com/ranyonsue/p/5984001.html

服务器传输超文本到本地浏览器的传送协议

基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。

属于应用层的面向对象的协议

HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接



客户端发送一个HTTP请求到服务器的请求消息包括以下格式：

**请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。**

![img](https://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip%7CimageView2/2)

## 一个完整的URL包括以下几部分：

1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符

2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用

3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口

4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”

5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名

6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分

7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。

# 浏览器渲染过程

### 浏览器组件

1. **用户界面**    除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。
2. **浏览器引擎** - 在用户界面和呈现引擎之间传送指令。
3. **渲染引擎(浏览器内核)** - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
   - **Trident**：俗称 IE 内核，也被叫做 MSHTML 引擎，目前在使用的浏览器有 IE11 -
   - **Gecko**：俗称 Firefox 内核，开源
   - **Webkit**：Safari 内核，也是 Chrome 内核原型，也被大量使用在移动端浏览器上。
   - **Blink**： 由 Google 和 Opera Software 开发，在Chrome（28及往后版本）、Opera（15及往后版本）和Yandex浏览器中使用。Blink 其实是 Webkit 的一个分支，添加了一些优化的新特性，例如跨进程的 iframe，将 DOM 移入 JavaScript 中来提高 JavaScript 对 DOM 的访问速度等，目前较多的移动端应用内嵌的浏览器内核也渐渐开始采用 Blink。
4. **网络** - 用于网络调用，比如 HTTP 请求。
5. **用户界面后端** - 绘制基本的窗口小部件
6. **JavaScript 解释器**      用于解析和执行 JavaScript 代码。
7. **数据存储**。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。

![img](https://user-gold-cdn.xitu.io/2018/2/22/161bb3c9aeaf8771?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 渲染过程



![img](https://user-gold-cdn.xitu.io/2018/2/22/161bb3c9b220f8cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



浏览器的**渲染过程**主要包括以下几步：

1. 解析HTML生成DOM树。  

2. 解析CSS生成CSSOM规则树。

   每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。

3. 将DOM树与CSSOM规则树合并在一起生成渲染树。

4. 遍历渲染树开始布局，计算每个节点的位置大小信息。

5. 将渲染树每个节点绘制到屏幕。

渲染过程中，**遇到script标签，如果是普通JS标签则同步加载并执行，阻塞页面渲染，如果标签上有defer / async属性则异步加载JS资源**

什么时候发生重绘、重排  https://juejin.cn/post/6844904083212468238#heading-9

### 渲染阻塞

https://juejin.im/entry/59e1d31f51882578c3411c77

存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外：

1. 当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。
2. JavaScript 可以查询和修改 DOM 与 CSSOM。
3. CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。

所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：

1. CSS 优先：引入顺序上，CSS 资源先于 JavaScript  资源。

2. JavaScript 应尽量少影响 DOM 的构建。

   

 1. **生成DOM树过程，遇到  js 会停下来直到脚本完成解析。**

 2. 如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，会延迟脚本执行和构建DOM（除了async 和 await），直至完成CSSOM的下载和构建。

    <u>(因此开发时CSS放在前面，通常把JS代码放到页面底部，且JavaScript 应尽量少影响 DOM 的构建)</u>
    
    <link>放置在<head></head>是**因为浏览器要先渲染页面呈现给用户**，在渲染时需要构建dom树(html标签内容)和render渲染树(css样式)，才能完整呈现，所以**放在头部优先加载**。
    
    而JS脚本文件比较大，且一般是后期JS引擎运行，渲染引擎会将控制权交给JS引擎而停止渲染，如果JS文件较大，会导致长时间白屏，影响用户体验，所以才会有JS<script>放在</body>之前。或者上一个问题中提到的优化加载的方式。

**补充**：

#### **异步加载js的方法**

**1.**    **async加载（异步加载JS文件）**

<script src="script.js" async="async"></script>

   HTML 5新定义的<script>属性。当渲染引擎解析文档时，遇到script标签继续解析，同时并行加载<script>标签中请求的资源。当<script>中的资源加载完成后，此时渲染浏览器才会暂停解析文档，将控制权交给JS引擎，执行指定脚本文件，执行完成后再移交控制权给渲染引擎继续解析文档（解析未完成的情况下）。

  async属性通过异步加载文件的方式解决了阻塞的问题，也因为异步执行，导致文件加载执行顺序不同。

**2.**    **defer加载（仅指加载JS文件）**

  使用方法:<script src="script.js" defer></script>

  严格按照<script>脚本顺序加载，加载的同时解析文档，但会延迟执行JS脚本，**文档解析完成后再执行JS脚本。**

![wfL82.png](https://segmentfault.com/img/bVWhRl?w=801&h=814)

### 构建渲染树

通过DOM树和CSS规则树  构建渲染树。浏览器会先从DOM树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的CSS样式规则并应用。

渲染树构建完成后，每个节点都是可见节点并且都含有其内容和对应规则的样式。这也是渲染树与DOM树的最大区别所在。display等于none的也不会被显示在这棵树里头，但是visibility：hidden的元素会显示。

### 渲染树布局

从渲染树的根节点开始遍历，确定每个节点对象在页面上的确切大小与位置，输出是一个盒子模型。

### 渲染树绘制

在绘制阶段，遍历渲染树，调用渲染器的**paint()**方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。

### css加载会造成阻塞吗？

https://zhuanlan.zhihu.com/p/43282197

1. css加载不会阻塞DOM树的解析
2. css加载会阻塞DOM树的渲染
3. css加载会阻塞后面js语句的执行  由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。

因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:

1. 使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)
2. 对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)
3. 合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)
4. 减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)

### **js和css文件位置**

**CSS和JS的位置会影响页面效率 --网页性能**

**js脚本文件的位置**

<u>js脚本应该放在底部</u>，如果js放在首部，下载执行js的时候，<u>会影响渲染行程绘制页面，</u>js的作用主要是处理交互，<u>交互必须得先让页面呈现才能进行</u>，为了保证用户体验，尽量让页面先绘制出来。

**CSS文件的位置**

（当页面存在外链 CSS 时，）浏览器会等待全部的 CSS 下载及解析完成后再渲染页面。<u>关键路径上的任何延迟都会影响首屏时间，需要尽快地将 CSS 传输到用户的设备，否则，（在页面渲染之前，）用户只能看到一个空白的屏幕。</u>

CSS文件放在顶部 一方面是因为放置顺序决定了下载的优先级，更关键的是浏览器的渲染机制。css在加载过程中不会影响到DOM树的生成，但是会影响到Render树的生成，进而影响到layout，所以一般来说，style的link标签需要尽量放在head里面，因为在解析DOM树的时候是自上而下的，而css样式又是通过异步加载的，这样的话，解析DOM树下的body节点和加载css样式能尽可能的并行，加快Render树的生成的速度。

<u>将CSS放在底部，页面可以逐步呈现，但在CSS下载并解析完毕后，已经呈现的文字和图片就要需要根据新的样式重绘，这是一种不好的用户体验。</u>

**广义而言，CSS 是（渲染）性能的关键，这是由于：**

1、浏览器直到渲染树构建完成后才会渲染页面；

2、渲染树由 DOM 与 CSSOM 组合而成；

3、DOM 是 HTML 加上（同步）阻塞的 JavaScript 操作（DOM 后的）结果；

4、CSSOM 是 CSS 规则应用于 DOM 后的结果；

5、使 JavaScript 非阻塞非常简单，添加 async 或 defer 属性即可；

6、相对而言，要让 CSS 变为异步加载是比较困难的；

记住这条经验法则：（理想情况下，）最慢样式表的下载时间决定了页面渲染的时间。

基于上述考虑，我们需要尽快构建 DOM 与 CSSOM。一般情况下，DOM 的构建是相对较快，（当请求某个页面时，）服务器响应的首个请求是 HTML 文档。但一般 CSS 是作为 HTML 的子资源而存在，因此 CSSOM 的构建通常需要更长的时间。

简答：**为什么通常推荐将 CSS 的link标签放置在head标签之间，而将script标签放置在 body闭合标签之前？**

<link>放置在<head></head>是因为浏览器要先渲染页面呈现给用户，在渲染时需要构建dom树(html标签内容)和render渲染树(css样式)，才能完整呈现，所以放在头部优先加载。

而JS脚本文件比较大，且一般是后期JS引擎运行，渲染引擎会将控制权交给JS引擎而停止渲染，如果JS文件较大，会导致长时间白屏，影响用户体验，所以才会有JS<script>放在</body>之前。或者上一个问题中提到的优化加载的方式。

### reflow与repaint：

HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。
repaint：元素的外观改变了，屏幕的一部分重画，<u>不影响整体布局</u>，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。
reflow： 元件的几何尺寸变了，需要重新验证并计算渲染树（Layout）
所以我们应该尽量减少reflow和repaint，这也是为什么现在很少有用table布局的原因之一。

**"重绘"不一定会出现"重排"，"重排"必然会出现"重绘"**

display:none 会触发 reflow，visibility: hidden的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框，所以visibility:hidden 只会触发 repaint，因为没有发生位置变化。

有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，又叫异步 reflow。
有些情况下，比如 resize 窗口，改变了页面默认的字体等。会马上进行 reflow。

重排影响范围

- 全局范围：从根节点`html`开始对整个渲染树进行重新布局。
- 局部范围：对渲染树的某部分或某一个渲染对象进行重新布局。把一个dom的宽高之类的几何信息定死，然后在dom内部触发重排，就只会重新渲染该dom内部的元素，而不会影响到外界。

**减少重排：**

避免设置大量的style属性，因为通过设置style属性改变结点样式的话，每一次设置都会触发一次reflow，所以最好是使用class属性

实现元素的动画，它的position属性，最好是设为absoulte或fixed，这样不会影响其他元素的布局

动画实现的速度的选择。比如实现一个动画，以1个像素为单位移动这样最平滑，但是reflow就会过于频繁，大量消耗CPU资源，以3个像素为单位移动则会好很多。

不要使用table布局，table中某个元素旦触发了reflow，整个table的元素都会触发reflow。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围



## 浏览器重绘(repaint)重排(reflow)与优化[浏览器机制]

https://juejin.im/post/5c15f797f265da61141c7f86#heading-13



## 找出一个网页中标签名以 h 开头的所有元素

```js
var eles = document.querySelectorAll('*');
function find(eles){
    var res = [];
    for(let i = 0; i < eles.length; i++) {
        if (eles[i].tagName.startsWith('H')){
            res.push(eles[i].tagName);
        }
    }
    return res;
}
var res = find(eles);
var _set = [...new Set(res)];
```

## 打印所有DOM

```js
var _body = document.getElementsByTagName("body")[0];
let j=0
for (var i = 0; i < _body.childNodes.length; i++) {
    if (_body.childNodes[i].nodeType == 1) {   //去除空格
        j++
        console.log("第" + j + "个标签：" + _body.childNodes[i].nodeName);
    }
    
}
```

## innerHTML,innerText,outerHTML

https://blog.csdn.net/shadow_zed/article/details/72846958

innerHTML,  包含内部标签

innerText,   除了内部标签的内容

outerHTML  包含自身标签，内部标签以及内容

# 两个静态html页面传值方法的总结

https://blog.csdn.net/csdn_ds/article/details/78393564

路由传参： 取值方便，可以跨域，利于页面分享，没有环境限制。缺点：url携带参数值的长度有限制。

放到cookie,优点：可以在同源内的的任意网页中访问，存储数据的周期可以自由设置。缺点：有长度限制

H5: localStorage：储存空间大，有5M存储空间。



# DOCTYPE有什么作用？标准模式与混杂模式如何区分？它们有何意义?

告诉浏览器用哪个版本的HTML规范来渲染文档。DOCTYPE不存在或形式不正确会导致HTML文档以混杂模式呈现。

 1）严格模式(标准模式)：排版和JS运作模式以该浏览器支持的最高标准运行。

  2）混杂模式(几乎标准模式)：页面以宽松的向后兼容的方式显示；模拟老浏览器的行为以防站点无法工作。

  3）怪异模式（Quirks mode）：使用浏览器自己的方式来解析执行代码

4.2 怪异模式quirk有哪些怪异的行为

1）最主要的比如IE与W3C的盒子模型不同（也是目前浏览器兼容的问题）；

2）可以设置行内元素的高宽

3）可设置百分比的高度，在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。

4）用margin:0 auto设置水平居中在IE下会失效 使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效,quirk模式下的解决办法，用text-align属性: body{text-align:center};#content{text-align:left}

5）设置图片的padding会失效

6）quirk模式下Table中的字体属性不能继承上层的设置 

# SEO

**1.请用html知识解决seo(搜索引擎优化)优化问题**

答：1.设置 TDK

TDK是SEO术语，是三个单词的缩写。 即：title/description/keywords。

2. html语义化标签，要简洁合理，这样css和js加载不全的时候，使html文档尽量清晰的展示，而不会特别乱

**2.简述一下你对HTML语义化的理解？**

丢失样式时能让页面呈现清晰结构。

有利于SEO和搜索引擎建立良好沟通，有助于爬虫抓取更多的信息，爬虫依赖于标签来确定上下文和各个关键字的权重。

方便其它设备解析。 便于团队开发和维护，语义化根据可读性。

关于HTML语义化，你知道的都有哪些标签？

header、article、address、nav、footer……

![image-20220712190627556](https://raw.githubusercontent.com/SprinaLF/pictures/master/img/image-20220712190627556.png)

# web worker（HTML5）

JavaScript是单线程模型，所有的任务都只能在一个线程上完成，一次只能做一件事情。 Web Worker的作用就是为JavaScript创建多线程环境，允许主线程创建Worker线程，将一些任务分配给后者运行，两者互不干扰。等到Worker线程完成计算任务，再把结果返回给主线程。

**优点：一些计算密集型或高延迟的任务，被Worker线程负担了，主线程（通常负责UI交互）就会很流畅，不会被阻塞或拖慢。**

**注意：Worker一旦新建成功，就会始终运行，不会被主线程的活动（比如按钮点击等）打断。有利于随时响应主线程的通讯，但是Worker比较耗费资源，不应该过度使用，一旦使用应该关闭**

**注意事项**

(1) 同源限制：分配给Worker线程运行的脚本文件，必须与主线程的脚本文件同源

(2) DOM限制：Worker线程所在的全局对象，与主线程的不一样，无法读取主线程所在的网页的DOM对象，也无法使用`document`、`windown`、`parent`这些对象。但是，Worker线程可以获取`navigator`和`location`对象。

(3) 通信联系：Worker线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。

(4) 脚本限制：Worker线程不能执行`alert()`和`confirm()`，但可以使用XMLHttpRequest对象发出Ajax请求

(5) 文件限制：Worker线程无法读取本地文件，即不能打开本机的文件系统 (file://)，它所加载的脚本，必须来自网络

# XHTML

XHTML更严格. 文档顶部doctype声明不同

1）标签必须闭合/ 2）标签名必须小写 3）标签元素必须正确嵌套 4）必须有根元素

5)属性值必加引号；

# HTML5新增

1）新的特殊内容元素(语义化标签)，如 article、footer、header、nav、section

2）新的表单控件，比如 calendar、date、time、email、url、search; 为input增加了color，emial,data ,range等类型

3）在多媒体方面规定了音频和视频元素audio和vedio

4）canvas画布，拖放，<u>地理定位</u>

5）在存储方面，提供了sessionStorage，localStorage,和本地离线存储，通过这些存储方式方便数据在客户端的存储和获取

6）浏览器异步，提供了多线程编程的web worker和websocket协议

# 渐进式渲染 (progressive rendering)

第一次只加载一个页面及其所需文件,页面第一次呈现速度稍快。但是每一次加载的速度基本相同的. 可用缓存进行优化 用户在网站中,停留时时间较长,点击较多时, 就会体现出劣势.

类似懒加载，一开始先加载首屏显示的内容，之后再随着时间或者滚动页面才进行后面的加载

 

**懒加载和预加载是常用的web优化的手段。**
 **懒加载**：(延迟加载)，延迟加载网络资源或符合某些条件时才加载资源。常见的就是图片延时加载。
 懒加载的意义：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。
 懒惰实现方式：
 1.第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟.
 2.第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。
 3.第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。

 

**预加载**：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。

两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。

懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。预加载应用如广告弹窗等。

# 小知识点

## 块状，行内，内联块状元素

1.**块状元素**

```xml
<div>、<p>、<h1>-<h6>、<ol>、<ul>、<form>、<dl>、<table>、<address>、<blockquote> 
```

1、独占一行

2、高度、宽度、行高以及顶和底边距可设置。

3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致）

2.**行内元素**(内联元素)

一个行内元素只占据它**对应标签的边框所包含的空间**。

```xml
<a>、<span>、<br>、<i>、<em>、<strong>、<label>、<q>、<var>、<cite>、<code>
```

（1）设置宽度 **width 无效**，宽度就是包含文字或图片的宽度。

（2）设置高度 **height 无效**，但可以通过 **line-height** 来设置。

（3）设置 margin 只有 **左右有效，上下无效。**

（4）设置 padding 只有 **左右有效，上下无效**。注意元素范围是增大了，但是对元素周围的内容是没影响的。

**行内元素和块级元素对比**

- 行内元素只能包含**数据和其他行内元素**。而块级元素可以包含**行内元素和其他块级元素**。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。
- 默认情况下，行内元素**不会以新行开始**，而块级元素会**新起一行**。
- 行内元素**不可以**设置宽高，块级元素**可以**设置宽高
- 行内元素**水平方向**的 margin 和 padding 可以生效。但**竖直方向**的 margin 和 padding 不能生效。块级元素可以设置margin，padding



**3.内联-块状元素 ** inline-block

 同时具备内联元素、块状元素的特点：
1.和其他元素都在一行上；

2.元素的高度、宽度、行高以及**顶和底边距**都可设置。

3.它也会有元素间出现空白区域的问题

常用的内联块状元素有：

```xml
<img>、<input>
```

补充：

若设置行内元素 **float:left/right**，则该行内元素转换为**块级元素** ，且具有浮动特性。

若为行内元素进行定位，**position:absolute** 或者 **position:fixed** 都会把行内元素转换为**块级元素**。



## *Inline-Block的坑 

空白间隙问题以及解决

http://layout.imweb.io/article/inline-block.html

## src和href的区别

src 

source的简写，【引用一个资源】，用来代替本身的内容。如img、script、iframe。如果不写src，本身没有内容，script会不存在脚本代码，img会显示x，iframe显示空白页。例如<script type="text/javascript" src="b.js">alert(1)</script>，b.js:alert(2); 标准的浏览器里会显示2，因为内容被替代；另一方面，当浏览器解析到这一句的时候暂停其他资源的下载处理，直至将该资源加载，编译，执行完，这也是为什么要把js放置在底部而不是头部。

在HTML body部分中的JavaScripts会在页面加载的时候被执行。放在body部分的脚本通常被用来生成页面的内容。这样不会出现大面积空白
 在HTML head部分中的JavaScripts会在被调用的时候才执行。当你把脚本放在head部分中时，可以保证脚本在任何调用之前被加载。

- 在head中时，所代表的functions只加载而不执行，执行是在某一事件触发后才开始。
-  在body中时，直接加载并执行

 

href 

Hypertext Reference的缩写，表示“超链接”， 建立一个“通道”，<u>让当前标签能够链接到目标地址上，并不是为了把目标拉进页面本身内来替换本身的内容，</u>例如a标签的href不会被当做一个资源替换自身，link标签本身并不包含实际的元素意义来做内容，需要rel明确的表示【被连接的文档是做什么的】。例如：<link href="head.css" rel="stylesheet"/>，浏览器解析到这一句的时候会识别该文档为css文件，会下载并不会停止当前文档处理，这也是为什么建议使用link方式来加载css而不是使用@import。

## 一般标签属性

​         id : id标识

​         style : 行内样式

​         href : a超链接地址,link外链css路径

​         src : 图片路径,script外链js路径

​         alt : 图片替换文字

## 表单控件属性

​         name : 控件名字

​         type : 控件类型

​         value : 控件值 

​         outline : 轮廓

## meta标签

提供了 HTML 文档的元数据。META元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者及其他元数据。

元数据可以被使用浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 Web 服务调用。

注意点：

<meta> 标签通常位于 <head> 区域内。

如果没有提供 name 属性，那么名称/值对中的名称会采用 http-equiv 属性的值。

## data-属性(HTML5)

data- *属性是 HTML5 中的新属性，用于存储页面或应用程序的私有自定义数据。data-*赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。
data-* 属性包括两部分：
1.属性名不应该包含任何大写字母，并且在前缀 "data-" 之后必须有至少一个字符
2.属性值可以是任意字符串

```html
<ul>
<li data-animal-type="鸟类">喜鹊</li>
<li data-animal-type="鱼类">金枪鱼</li> 
<li data-animal-type="蜘蛛">蝇虎</li> 
</ul>
```

**获取**

属性集可以通过对象的dataset属性获取，不支持该属性的浏览器可以通过 getAttribute方法获取。

PS：需要注意的是，data-之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格

例子：<div id="myID" data-my-attr = “test"></div>，

获取属性值：

使用dataset，getElementById("myID").dataset.myAttr

使用getAttribute方法，getElementById("myID").getAttribute('data-my-attr')

## 自闭合标签

在HTML中，标签分为两种：一般标签和自闭合标签。

**只有开始符号而没有结束符号，因此不可以在内部插入标签或文字**

| 标签      | 说明                             |
| :-------- | :------------------------------- |
| <meta />  | 定义网页的信息（供搜索引擎查看） |
| <link />  | 引入“外部CSS文件”                |
| <br />    | 换行标签                         |
| <hr />    | 水平线标签                       |
| <img />   | 图片标签                         |
| <input /> | 表单标签                         |

## DTD（Document Type Definition）：文档类型定义

html实际上也是一种xml，而DTD就是对XML进行约束的一种规范。

## 很多网站不常用table iframe这两个元素，知道原因吗？ 

答：浏览器页面渲染的时候是从上至下的，而table 和 iframe 这两种元素会改变这样渲染规则，等待自己元素内的内容加载完才整体渲染。用户不友好

## jpg和png格式的图片有什么区别？

答： jpg有损压缩，png无损，相同图片jpg体积小。一些官网的banner图一般很大，适合jpg类型。但png分8位的和24位的，8位的体积会小很多，但在某些浏览器下8位的png图片会有锯齿。

## 浏览器内核

**1. 常用浏览器内核都是什么？**

答： 内核：IE的是 Trident  

火狐的是 Gecko

chrome和safari 用的是 Webkit

360和搜狗这些分极速模式和兼容模式，极速模式用的Webkit的内核，兼容模式用的Trident内核。

**2. 对浏览器内核的理解？**

主要分成两部分：渲染引擎和JS引擎。

渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。
 JS引擎：解析和执行javascript来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。

## 页面导入样式时，使用link和@import有什么区别？

都是外部引用CSS方式，区别：

link是xhtml标签，除了加载css外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS

link引用CSS时候，页面载入时同时加载；@import需要在页面完全加载以后加载，而且@import被引用的CSS会等到引用它的CSS文件被加载完才加载

link是xhtml标签，无兼容问题；@import是在css2.1提出来的，低版本的浏览器不支持

link支持使用javascript控制去改变样式，而@import不支持

link方式的样式的权重高于@import的权重

import在html使用时候需要<style type="text/css">标签

## title与h1的区别、b与strong的区别、i与em的区别？

title属性没有明确意义，只表示标题；h1表示层次明确的标题，对页面信息的抓取有很大的影响
 strong标明重点内容，语气加强含义；b是无意义的视觉表示
 em表示强调文本；i是斜体，无意义的视觉表示
 **视觉**样式标签：b i u s
 **语义**样式标签：strong em ins del code



# 尚未整理的题目

## HTML5的文件离线储存怎么使用，工作原理是什么？

在线情况下，浏览器发现HTML头部有manifest属性，它会请求manifest文件，如果是第一次访问，那么浏览器就会根据manifest文件的内容下载相应的资源，并进行离线存储。如果已经访问过并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面。然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不会做任何操作，如果文件改变了，那么就会重新下载文件中的资源，并且进行离线存储。例如，

在页面头部加入manifest属性

<html manifest='cache.manifest'>

在cache.manifest文件中编写离线存储的资源

#  

## 12 iframe框架有那些优缺点？

优点：原封不动的把嵌入的网页展现出来。如果有多个网页引用iframe，只需要修改iframe，就可以实现调用的每一个页面内容的更改，方便快捷。网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，增加代码的可重用。加载缓慢的第三方内容如图标和广告可由iframe解决。

缺点：搜索引擎无法解读 出现各种滚动条 增加服务器的http请求

## 15 如何实现浏览器内多个标签页之间的通信?

WebSocket  SharedWorker

也可以调用 localstorge、cookies 等本地存储方式。 localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信。localstorage是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信(ps：session是会话级的存储空间，每个标签页都是单独的）。

注意：Safari 在无痕模式下设置 localstorge 值时会抛出QuotaExceededError 的异常

## 16 页面可见性（Page Visibility）API 可以有哪些用途？

通过visibility state的值得检测页面当前是否可见，以及打开网页的时间。

在页面被切换到其他后台进程时，自动暂停音乐或视频的播放。

17 如何在页面上实现一个圆形的可点击区域？

map+area或者svg

border-radius

纯js实现，一个点不在圆上的算法

## 18 实现不使用 border 画出1px高的线，在不同浏览器的Quirks mode和CSS Compat模式下都能保持同一效果

<div style="height:1px;overflow:hidden;background:red"></div>

## 5、解释一下utf-8和GBK和ISISO8859-2 字符集

charset 属性规定 HTML 文档的字符编码。

UTF-8是一种针对Unicode的可变长度字符编码，又称万国码。UTF-8用1到6个字节编码UNICODE字符。用在网页上可以同一页面显示中文简体繁体及其它语言（如英文，日文，韩文）。

GBK是汉字编码，是双字节码，可表示繁体字和简体字。

ISO8859-2 字符集，也称为 Latin-2，收集了 东欧 字符。

8、组成HTML网页必不可少的是，head标签中必不可少的是（此题略不严谨，HTML5中可以省略HTML组成网页的部分）

Html,head,body;title.  title可有可无。但是mate中的chartset 一定要有，要不然会乱码。这是实际开发的经验。

 

## 12、关于置换元素和不可替换元素

置换元素：浏览器根据元素的标签和属性，来决定元素的具体显示内容。 例如：浏览器会根据<img>标签的src属性的值来读取图片信息并显示出来，而如果查看(x)html代码，则看不到图片的实际内容；<input>标签的type属性来决定是显示输入框，还是单选按钮等。 (x)html中 的<img>、<input>、<textarea>、<select>、<object>都是置换元素。这些元素往往没有实际的内容，即是一个空元素。置换元素在其显示中生成了框，这也就是有的内联元素能够设置宽高的原因。 （因此img是inline还可以设置宽高）

不可替换元素：(x)html 的大多数元素是不可替换元素，即其内容直接表现给用户端（如浏览器）。例如：<label>label中的内容</label> 标签<label>是一个非置换元素，文字label中的内容”将全被显示。

## 为什么替换元素可设置宽高

· 几乎所有的**替换元素**都是**行内元素**，例如`<img>`、`<input>`等等。

· 替换元素一般有内在尺寸，所以具有width和height，可以设定。例如你不指定img的width和height时，就按其内在尺寸显示，也就是图片被保存的时候的宽度和高度。对于表单元素，浏览器也有默认的样式，包括宽度和高度。

 

## 13、HTML元素的显示优先级

帧元素（frame）>HTML元素，表单元素总>非表单元素 

## 21、常见的浏览器端存储的方式 

：

Cookie：cookie会随着每次HTTP请求头信息一起发送，无形中增加了网络流量，另外，cookie能存储的数据容量有限，根据浏览器类型不同而不同，IE6大约只能存储2K。 

Cookie可以实现记录访问者的信息、在页面之间传递信息、自动识别用户。

Flash ShareObject：这种方式能能解决上面提到的cookie存储的两个弊端，而且能够跨浏览器，应该说是目前最好的本地存储方案。不过，需要在页面中插入一个Flash，当浏览器没有安装Flash控件时就不能用了。所幸的是，没有安装Flash的用户极少。 

缺点：需要安装Flash插件。

Google Gear：Google开发出的一种本地存储技术。 缺点：需要安装Gear组件。

userData：IE浏览器可以使用userData来存储数据，容量可达到640K，这种方案是很可靠的，不需要安装额外的插件。缺点：它仅在IE下有效。

sessionStorage：用这种方式存储的数据仅窗口级别有效，**同一个窗口**（或者Tab）页面刷新或者跳转，都能获取到本地存储的数据，当新开窗口或者页面时，原来的数据就失效了。

缺点：IE不支持、不能实现数据持久保存。

globalStorage：类似于IE的userData。 缺点：IE不支持。

localStorage：localStorage是Web Storage互联网存储规范中的一部分，现在在Firefox3.5、Safari 4和IE8中得到支持。 缺点：低版本浏览器不支持。

结论： Flash shareobject是不错的选择，如果你不想在页面上嵌入Flash，可以结合使用userData(IE6+)和globalStorage(Firefox2+)和localStorage(chrome3+)实现跨浏览器。

## method 属性

浏览器使用 method 属性设置的方法将表单中的数据传送给服务器处理。

 POST 方法：首先，浏览器将与 action 属性中指定的表单处理服务器建立联系，一旦建立连接之后，浏览器就会按**分段传输**的方法将数据发送给服务器。

在服务器端，一旦 POST 样式的应用程序开始执行时，就应该从一个标志位置读取参数，而一旦读到参数，在应用程序能够使用这些表单值以前，必须对这些参数进行解码。用户特定的服务器会明确指定应用程序应该如何接受这些参数。

 GET 方法，这时浏览器会与表单处理服务器建立连接，然后直接在一个传输步骤中**发送所有**的表单数据：**浏览器会将数据直接附在表单的** **action URL** **之后**。这两者之间用问号进行分隔。

POST 还是 GET？

希望获得最佳表单传输性能，采用 GET 方法发送只有少数简短字段的小表单。

一些服务器操作系统在处理可以立即传递给应用程序的命令行参数时，会限制其数目和长度，在这种情况下，对那些有许多字段或是很长的文本域的表单来说，就应该采用 POST 方法来发送。

如果你在编写服务器端的表单处理应用程序方面经验不足，应该选择 GET 方法。如果采用 POST 方法，就要在读取和解码方法做些额外的工作

如果想在表单之外调用服务器端的应用程序，而且包括向其传递参数的过程，就要采用 GET 方法，因为该方法允许把表单这样的参数包括进来作为 URL 的一部分。而另一方面，使用 POST 样式的应用程序却希望在 URL 后还能有一个来自浏览器额外的传输过程，其中传输的内容不能作为传统 <a> 标签的内容。