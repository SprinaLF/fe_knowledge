# 从输入URL到页面展示

![img](https://filescdn.proginn.com/699ae93abb42cecba50760d04df74577/60ac0b5f7f6bf49e67efa9b37a5aeed5.webp)

https://juejin.im/post/5b148a2ce51d4506965908d2 （详细）

区分：浏览器工作、服务器所做工作

- **URL输入**

- **DNS解析**

  查找顺序： 浏览器缓存--> 操作系统缓存--> 本地host文件 --> 路由器缓存--> ISP DNS缓存 --> 顶级DNS服务器/根DNS服务器(DNS查询)

  ![img](https://user-gold-cdn.xitu.io/2018/6/4/163c83c423b021ca?imageslim)

- **TCP连接**

  1.三次握手

  第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

  第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

  第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

  2.为什么需要三次握手？

   防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误

- **发送HTTP请求**

  建立了TCP连接之后，发起一个http请求。

  一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法

  客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分：

  - 请求方法URI协议/版本
  - 请求头(Request Header)
  - 请求正文

   补充：服务器重定向   301，302区别https://juejin.im/post/5b148a2ce51d4506965908d2

- **服务器处理请求**

- **服务器响应请求**

  HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是：

  - 状态行        ->状态码
  - 响应头/消息报头  (Response Header) 
  - 空行
  - 响应正文

- **浏览器解析渲染页面**

**遇到script标签，如果是普通JS标签则同步加载并执行，阻塞页面渲染，如果标签上有defer / async属性则异步加载JS资源**

- **连接结束**

  四次挥手

  第一步，当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。

  第二步，主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。

  第三步，主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。

  第四步，主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。



## 三次握手

![img](https://camo.githubusercontent.com/92800a8405ffab35ba53a6fc2aa664385be4ab24/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323434383735322d363030663232613930323432623536652e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

https://juejin.im/post/5d9c284b518825095879e7a5

1 主机A向主机B发送一个含有同步序列号的标志位的数据段给主机B ,向B请求建立连接,通过这个数据段,
 主机A告诉主机B 两件事:我想要和你通信;<u>你可以用哪个序列号作为起始数据段来回应我.</u>
 2 主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:     我已经收到你的请求了,你可以传输数据了;你要用哪佧序列号作为起始数据段来回应我
 3 主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B 的数据段:"我已收到回复,我现在要开始传输实际数据了

特点
 没有应用层的数据
 <u><u>SYN这个标志位只有在TCP建产连接时才会被置1</u>。握手完成后SYN被置0</u>

### 为什么需要三次握手

<u>防止已失效的连接请求报文段突然又传送到了服务端，产生错误</u>

“已失效的连接请求报文段” ：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，延误到连接释放以后的某个时间到达server。server收到后误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。

假设不采用“三次握手”，只要server发出确认，新的连接就建立了。client并没有发出建立连接的请求，不会理睬server的确认，也不会向server发送数据。但server却以为新连接已建立，并一直等待client发来数据，浪费资源

采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。防止server端一直等待，浪费资源。

## 四次挥手

1 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求
 2 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1
 3 由B 端也提出反方向的关闭请求,将FIN置1
 4 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.

**为什么需要四次**？

因为TCP是全双工通信的

   （1）第一次

​     主动方发送断开连接的请求（FIN报文）给被动方时，仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。

​    （2）第二次

​     **<u>被动方此时有可能还有相应的数据报文需要发送</u>，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。**

   （3）第三次挥手

​    **被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）**。

   （4）第四挥手

​    <u>如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。</u>

 由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础



# 网络模型

每层的协议？

https://blog.csdn.net/qq_22238021/article/details/80279001

![image-20210507180054364](/Users/wenxin/Library/Application Support/typora-user-images/image-20210507180054364.png)

## OSI七个层次的功能

**物理层   比特**    传输比特流。 为数据链路层提供物理连接

通过媒介传输比特（就是由1、0转化为电流强弱来进行传输,到达目的地后再转化为1、0，也就是常说的数模转换与模数转换），规定通信设备的机械的、电气的、功能的和过程的特性。主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。用以建立、维护和拆除物理链路连接。

机械 特性规定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等;电气特性规定了在物理连接上传输bit流时线路上信号电平的大小、阻抗匹配、传输速率 距离限制等; 功能特性是指对各个信号先分配确切的信号含义，即定义了DTE和DCE之间各个线路的功能;规程特性定义了利用信号线进行bit流传输的一组 操作规程，是指在物理连接的建立、维护、交换信息是，DTE和DCE双放在各电路上的动作系列。在这一层，数据的单位称为比特(bit)。属于物理层定义的典型规范代表包括：EIA/TIA RS-232、EIA/TIA RS-449、V.35、RJ-45等。

**数据链路层**：（帧Frame）

在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，将<u>比特组装成帧和点到点的传递</u>。通过差错控制提供数据帧(Frame)在信道上无差错的传输，并进行各电路上的动作系列。<u>数据链路层在不可靠的物理介质上提供可靠的传输</u>。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。在这一层，数据的单位称为帧(frame)。数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。

**网络层**：（包PackeT）

在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。

为了将数据分组从源（源端系统）送到目的地（目标端系统），网络层的任务就是<u>选择合适的路由和交换节点</u>，使源的传输层传下来的分组信息能够正确无误地按照地址找到目的地，并交付给相应的传输层，即完成网络的寻址功能。  　

**传输层**：提供端到端的可靠报文传递和错误恢复（段Segment）

定义了一些传输数据的协议和端口号（WWW端口80等），如： 
TCP（transmission control protocol –传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据） 
UDP（user datagram protocol–用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 

传输层是高低层之间衔接的接口层。数据传输的单位是报文，当报文较长时将它分割成若干分组,然后交给网络层进行传输。<u>传输层是计算机网络协议分层中的最关键一层，该层以上各层将不再管理信息传输问题。</u> 

**会话层**：建立、管理和终止会话（会话协议数据单元SPDU）

通过运输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名） 　

该层对传输的报文提供同步管理服务。在两个不同系统的互相通信的应用进程之间建立、组织和协调交互。例如，确定是双工还是半双工工作。 

**表示层**：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）

通过运输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。该层的主要任务是把所传送的数据的抽象语法变换为传送语法，即把不同计算机内部的不同表示形式转换成网络通信中的标准表示形式。此外，对传送的数据加密（或解密）、正文压缩（或还原）也是表示层的任务。  　

**应用层**：允许访问OSI环境的手段（应用协议数据单元APDU）

<u>直接面向用户</u>，最高层。为用户提供应用的接口，即提供不同计算机间的文件传送、访问与管理，电子邮件的内容处理，不同计算机通过网络交互访问的虚拟终端功能等。

![img](https://pic2.zhimg.com/80/v2-ffc9a0be70d75e81141b3b09190680f5_1440w.jpg)

## 各层的协议

应用层



传输层

### tcp和udp

TCP（Transmission Control Protocol，传输控制协议）提供的面向连接，可靠的字节流服务。即客户和服务器交换数据前，必须现在双方之间建立一个TCP连接，之后才能传输数据。并且提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。

UDP（User Data Protocol，用户数据报协议）是一个简单的面向数据报的运输层协议。它不提供可靠性，只是把应用程序传给IP层的数据报发送出去，但是不能保证它们能到达目的地。由于UDP在传输数据报前不用再客户和服务器之间建立一个连接，且没有超时重发等机制，所以传输速度很快。

区别：

https://blog.csdn.net/sifanchao/article/details/82285018?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

**tcp**

​	面向连接：      三次握手建立连接，四次挥手断开连接

​	可靠传输：      校序重流拥     序列号 确认应答 超时重传 拥塞控制

​	面向字节流

**udp**

​	无连接：		知道对端的IP和端口号就直接进行传输, 不需要建立连接。

​	不可靠(尽最大努力交付)：		没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息。
​	面向数据报：不能够灵活的控制读写数据的次数和数量，发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不会拆分, 也不会合并。    

网络层

## 各层的设备





## DNS

https://zhuanlan.zhihu.com/p/61394192

DNS解析**流程**分为**递归查询**和**迭代查询**，递归查询是以本地名称服务器为中心查询，迭代查询是以DNS客户端，也就是客户机器为中心查询

![img](https://images2015.cnblogs.com/blog/464291/201707/464291-20170703113844956-354755333.jpg)

# HTTP

超文本传输协议（HTTP, HyperText Transfer Protocol）

**无状态**的协议，它位于[OSI七层模型](http://itbilu.com/nodejs/core/VkcdcFq9.html#OSI)的传输层。HTTP客户端会根据需要构建合适的HTTP请求方法，而HTTP服务器会根据不同的HTTP请求方法做出不同的响应

##  **如何理解HTTP协议的 “无连接，无状态” ？**

**无连接的含义 ** https://segmentfault.com/a/1190000015821798

<u>**限制每次连接只处理一个请求**。服务器处理完客户的请求，并收到应答后，即断开连接。这种方式可以节省传输时间。</u>

可见，**HTTP不是字面意义上的没有连接**，事实上，这个定义也符合HTTP短连接的定义，但**无连接强调的是HTTP的特性，短连接可理解为一种实现**。

无连接的含义也可以**结合HTTP无状态的含义在应用层面上去理解**：每一个请求都拥有自己的请求体，期望接收到唯一的对应的响应体，<u>而每一次的请求都相互独立，与上一次或下一次的请求毫无关系</u>，哪怕是在同一条连接中（后面说的长连接）。<u>正因为这个特性，业务代码实现的时候，无需考虑请求之间的关系，</u>只需考虑业务是如何在当前请求完成的。

而HTTP真正的连接，根据计算机网络体系的协议栈可知，是通过运输层的TCP协议实现的，下层向上层提供了可靠的连接，上层屏蔽了下层的具体实现，所有的操作均在可靠的连接基础之上。HTTP使用TCP的目的是为了保证数据传输的可靠性和完整性。



**无状态**指协议<u>对于事务处理没有记忆能力</u>，服务器不知道客户端什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给发送数据过来，但是，发送完不会记录任何信息。

缺少状态意味着如果后续处理需要前面的信息，则必须重传，这样可能导致每次连接传送的数据量增大。

HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复信息。

客户端与服务器进行动态交互的 Web 应用程序出现后，<u>HTTP 无状态的特性严重阻碍了这些应用程序的实现</u>，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。<u>于是，两种用于保持 HTTP 连接状态的技术： Cookie，Session。</u>

# cookie session

**Cookie可以保持登录信息到用户下次与服务器的会话，换句话说，下次访问同一网站时，用户会发现不必输入用户名和密码就已经登录了**（当然，不排除用户手工删除Cookie）。而还有一些Cookie在用户退出会话的时候就被删除了，这样可以有效保护个人隐私。

最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户登录信息。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入 Cookies，以便最后付款时提取信息。

**与 Cookie 相对的一个解决方案是 Session，通过服务器保持状态的。**

当客户端访问服务器时，服务器根据需求设置 Session，将会话信息保存在服务器上，同时将标示 Session 的 SessionId 传递给客户端浏览器，浏览器将这个 SessionId 保存在内存中，我们称之为无过期时间的 Cookie。浏览器关闭后，这个 Cookie 就会被清掉，它不会存在于用户的 Cookie 临时文件。

以后浏览器每次请求都会额外加上这个参数值，服务器会根据这个 SessionId，就能取得客户端的数据信息。

如果客户端浏览器意外关闭，服务器保存的 Session 数据不是立即释放，此时数据还会存在，只要我们知道那个 SessionId，就可以继续通过请求获得此 Session 的信息，因为此时后台的 Session 还存在，当然我们可以设置一个 Session 超时时间，一旦超过规定时间没有客户端请求时，服务器就会清除对应 SessionId 的 Session 信息。

**cookie**  https://bbs.huaweicloud.com/blogs/detail/235409 (最全cookie面试问题)

cookie详解 https://zhuanlan.zhihu.com/p/52091630

Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，实际上Cookie是服务器在**本地机器**上存储的一小段文本，并**随着每次请求发送到服务器**。

**Cookie技术通过请求和响应报文中写入Cookie信息来控制客户端的状态。**

1. 访问某个网站时，服务器首先根据浏览器的编号生成一个cookie 返回给客户端。客户端下次再访问时就会将自己本地的cookie 加上url访问地址一同给服务器。服务器读出来**以此来辨别用户的状态**。

   ![cookie是什么，如何使用cookie？](https://exp-picture.cdn.bcebos.com/a007a9b1eef97fbdb9e85a00b74133bad2413328.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1)

   2    当你浏览某网站时，由Web服务器置于你硬盘上的一个非常小的文本文件，它可以记录你的用户ID、密码、浏览过的网页、停留的时间等信息。当你再次来到该网站时，网站通过读取Cookie，得知你的相关信息，就可以做出相应的动作，如在页面显示欢迎你的标语，或者让你不用输入ID、密码就直接登录等等。如果你清理了Cookie，那么你曾登录过的网站就没有你的修改过的相关信息。

网站通过Cookie信息来记忆以及辨认你的帐号，它可以记忆你的偏好设置。它还可以使网站提供个性化的内容，例如在淘宝上购物，淘宝可以记忆你所查看过的产品并据此来向你来推荐商品，即便你没有登陆个人帐号。

**session**

服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的信息进行验证，然后把用户的认证状态与Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段Set-Cookie 内写入Session ID（如PHPSESSID=l128ogl…）。你可以把Session ID 想象成一种<u>用以区分不同用户的唯一Id</u>。

步骤三：客户端接收到从服务器端发来的Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID 也随之发送到服务器。服务器端可通过验证接收到的Session ID 验证状态。

### **cookie与session的区别**

```
cookie和session都是用来跟踪浏览器用户身份的会话方式。
```

(1)cookie数据存放在客户的浏览器上，session数据放在服务器上
(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session
(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE
(4)一个站点在客户端存放的COOKIE不能超过3K
所以：**将登陆信息等重要信息存放为SESSION**;其他信息如果需要保留，可以放在COOKIE中

### cookies，sessionStorage和localStorage的区别？

在之前都是使用cookie的，

HTML5提供两种本地存储方案：localStorage：用于持久化的本地存储，数据永不过期，关闭浏览器不丢失。   sessionStorage ：同一个会话的页面才能访问并且当会话结束后数据也会随之销毁，不是一种持久化的本地存储，仅仅是会话级别的存储



共同点：都保存在浏览器端，且是同源的。



区别：cookies是为了标识用户身份而存储在用户本地终端上的数据，始终在同源http请求中携带，**即cookies在浏览器和服务器间来回传递**，**sessionstorage和localstorage不自动把数据发给服务器，仅在本地保存。**

**存储大小**不同。cookie保存的数据不能超过4k，sessionstorage和localstorage可达到5M。

**数据的有效期**不同。<u>cookie在设置的cookie过期时间前一直有效</u>，即使浏览器关闭。sessionstorage仅在浏览器窗口关闭之前有效。localstorage始终有效。

作用域不同。cookie在所有的同源窗口都是共享；sessionstorage不在不同的浏览器共享，即使同一页面，localstorage在所有同源窗口都是共享（"同源":  协议、域名、端口相同）

### session

![img](https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=2169381799,1320776160&fm=173&app=49&f=JPEG?w=450&h=300&s=440A5532435E4DC80AD4B1DB0000C0B2)

session称为会话信息，位于web服务器上，主要负责访问者与网站之间的交互，当访问浏览器请求http地址时，将传递到web服务器上并与访问信息进行匹配， 当关闭网站时就表示会话已经结束，网站无法访问该信息了，所以它无法保存永久数据，我们无法访问以及禁用网站

Session与cookie功能效果相同。**Session与Cookie的区别在于Session是记录在服务端的，而Cookie是记录在客户端的。**

解释session：当访问服务器否个网页的时候，会在服务器端的内存里开辟一块内存，这块内存就叫做session，而这个内存是跟浏览器关联在一起的。这个浏览器指的是浏览器窗口，或者是浏览器的子窗口，意思就是，只允许当前这个session对应的浏览器访问，就算是在同一个机器上新启的浏览器也是无法访问的。而另外一个浏览器也需要记录session的话，就会再启一个属于自己的session

原理：HTTP协议是非连接性的，取完当前浏览器的内容，然后关闭浏览器后，链接就断开了，而没有任何机制去记录取出后的信息。而当需要访问同一个网站的另外一个页面时(就好比如在第一个页面选择购买的商品后，跳转到第二个页面去进行付款)这个时候取出来的信息，就读不出来了。所以必须要有一种机制让页面知道原理页面的session内容。

问题：如何知道浏览器和这个服务器中的session是一一对应的呢？又如何保证不会去访问其它的session呢？

原理解答：就是当访问一个页面的时候给浏览器创建一个独一无二的号码，也给同时创建的session赋予同样的号码。这样就可以在打开同一个网站的第二个页面时获取到第一个页面中session保留下来的对应信息（理解：当访问第二个页面时将号码同时传递到第二个页面。找到对应的session。）。这个号码也叫sessionID，session的ID号码，session的独一无二号码。

## cookie session token

保持登录状态https://blog.csdn.net/qq_39385118/article/details/86350049

## **HTTP发展**

https://juejin.cn/post/6844903923136856078

- HTTP/2
  这个版本是最新发布的版本，于今年5月（2015年5月）做HTTP标准正式发布。HTTP/2通过支持请求与相应的多路重用来减少延迟，通过压缩HTTP头字段将协议开销降到最低，同时增加了对请求优先级和服务器端推送的支持。

**Http2.0相比于1.1**   https://segmentfault.com/a/1190000016975064

\1. HTTP版本与HTTP请求方法

http发展 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP

在进行HTTP请求时，客户端在请求时会告诉服务器它采用的协议版本号，而服务器则会在使用相同或者更早的协议版本进行响应(协议向下兼容)。



HTTP/0.9

最初版本的HTTP协议并没有版本号，后来它的版本号被定位在 0.9 以区分后来的版本。

**只有一行**，以唯一可用方法[`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET)开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。

```html
GET /mypage.html
```

在HTTP通讯也没有指定版本号，也不支持请求头信息。客户端向服务器传递信息的能力非常有限。

响应也极其简单的：只包含响应文档本身。

```html
<HTML>
这是一个非常简单的HTML页面
</HTML>
```

跟后来的版本不同，HTTP/0.9 的响应内容并不包含HTTP头，这意味着只有HTML文件可以传送，无法传输其他类型的文件；也没有状态码或错误代码：一旦出现问题，一个特殊的包含问题描述信息的HTML文件将被发回，供人们查看。



HTTP/1.0

这个版本是第一个在HTTP通讯中指定版本号的协议版本，至今仍被广泛采用，特别是在代理服务器中。

支持：**GET、POST、HEAD三种HTTP请求方法。**



HTTP/1.1 8种方法

 当前正在使用的版本。该版本默认采用持久连接，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。

HTTP/1.1新增了：OPTIONS、PUT、DELETE、TRACE、CONNECT五种HTTP请求方法。



HTTP/2

HTTP/2通过支持请求与相应的多路重用来减少延迟，通过压缩HTTP头字段将协议开销降到最低，同时增加了对请求优先级和服务器端推送的支持。新一代的 HTTP/2 协议的支持需以 HTTPS 为基础。

HTTP/1.1之后增加的方法

在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：

PATCH

PATCH方法出现的较晚，它在2010年的[RFC 5789](http://tools.ietf.org/html/rfc5789)标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：

但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。

当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。

# 状态码

https://mp.weixin.qq.com/s?__biz=MzA4MjkxMzMyNg==&mid=2654068952&idx=1&sn=1bd63a71610d73fcd563888d6f93398d&scene=24&srcid=0804843QrwLCsKWGYxfPum2H#wechat_redirect

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：

请求行（request line）、请求头部（header）、空行和请求数据 四个部分组成。

网页应用在接收和解释请求消息后服务器会返回一个HTTP响应消息，而HTTP响应：状态行、消息报头、空行，响应正文

格式如：HTTP-Version Status-Code Reason-Phrase CRLF

其中，HTTP-Version 表示服务器HTTP协议的版本;Status-Code 表示服务器发回的响应状态代码;Reason-Phrase 表示状态代码的文本描述。



第一个数字定义的是响应的类别

1XX 信息性状态码（Informational）服务器正在处理请求

2XX 成功（Success）请求已正常处理完

3XX 重定向状态码（Redirection）需要进行额外操作以完成请求

4XX 客户端错误状态码（Client Error）客户端原因 导致服务器无法处理请求

5XX 服务器错误状态码（Server Error）服务器原因 导致处理请求出错

 

常见状态代码

200 OK ：客户端请求成功

201 Created  请求已经被成功处理，并且创建了新的资源。新的资源在应答返回之前已经被创建。同时新增的资源会在应答消息体中返回，其地址或者是原始请求的路径，或者是 [`Location`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location) 首部的值。这个状态码的常规使用场景是作为 [`POST`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST) 请求的返回值。

<u>204 No Content  请求已成功处理，但是没有内容返回（就应该没有内容返回）</u>

206 Partial Content  服务器已经完成了部分GET请求

300 多重选择   请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择

**301** Moved Permanently  永久重定向，请求的资源已经永久的搬到了其他位置

**302** Found 临时重定向，表示请求的资源临时搬到了其他位置。是临时发生的，所以客户端在之后的请求中还应该使用原本的 URI。

   由于**历史原因**，用户代理可能会在重定向后的请求中把 POST 方法改为 GET 方法。如果不想这样，应该使用 307（Temporary Redirect） 状态码。

https://zhuanlan.zhihu.com/p/60669395  302、303 与 307的联系

303 **表示服务器要将浏览器重定向到另一个资源**，这个资源的 URI 会被写在响应 Header 的 Location 字段。从语义上讲，重定向到的资源并不是你所请求的资源，而是对你所请求资源的一些描述。303 常用于将 POST 请求重定向到 GET 请求，比如你上传了一份个人信息，服务器发回一个 303 响应，将你导向一个“上传成功”页面。

不管原请求是什么方法，重定向请求的方法都是 GET（或 HEAD，不常用）。

304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。（服务端已经执行了GET，但文件未变化。）

307 的定义实际上和 302 是一致的，唯一区别：307 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上。



400 Bad Request 客户端请求有语法错误，不能被服务器所理解

**401 Unauthorized 表示发送的请求需要有HTTP认证信息或者是认证失败了（请求未经授权）**

403 Forbidden  表示对请求资源的访问被服务器拒绝了   跨域时会出现这种情况

404 Not Found 表示服务器找不到你请求的资源



500 Internal Server Error 表示服务器执行请求的时候出错了

502   网关错误  作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个**无效的响应**  

503 Service Unavailable 表示服务器超负载或正停机维护，无法处理请求，一段时间后可能恢复正常

504      充当网关或代理的服务器，**未及时从远端服务器获取请求**。  实际上504很少会遇到，通常这个错误是由于nginx配置不当引起的，比如你将你的nginx的超时时间设置为300，那么如果此次请求的响应时间超过了300，你就会看到504这个报错。

通俗的来说，nginx作为一个代理服务器，将请求转发到其他服务器或者php-cgi来处理，当nginx收到了无法理解的响应时，就返回502。当nginx超过自己配置的超时时间还没有收到请求时，就返回504错误。从网络角度，502已经与后端建立了连接，但超时；504与后端连接未建立，超时





## HTTP请求方法介绍

**get** **和post的区别**

· get用来获取数据，post用来提交数据 

· get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节），post无限制。 

· get请求的数据会附加在url之 ，以 " ？ "分割url和传输数据，多个参数用 "&"连接，数据在URL中可以看到。

而post请求会把请求的数据放在http请求体中。 

· get是明文传输，post是放在请求体中，但是开发者可以通过抓包工具看到，也相当于是明文的。 

· get请求会保存在浏览器历史记录中，还可能保存在web服务器的日志中

- GET产生的URL地址可以被Bookmark，而POST不可以。

- GET请求会被浏览器主动cache，而POST不会，除非手动设置。

 get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。

<u>GET/POST都是TCP链接。</u>

不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同响应。

其他重要区别：

![image-20210512155328965](/Users/wenxin/Library/Application Support/typora-user-images/image-20210512155328965.png)

https://www.cnblogs.com/logsharing/p/8448446.html

![image-20210510151152549](/Users/wenxin/Library/Application Support/typora-user-images/image-20210510151152549.png)

![image-20210512200159320](/Users/wenxin/Library/Application Support/typora-user-images/image-20210512200159320.png)

GET

会显示请求指定的资源。一般GET方法应该只用于数据读取，而不应当用于会产生副作用的非[幂等](https://developer.mozilla.org/zh-CN/docs/Glossary/Idempotent)的操作中。

GET方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。

GET请求会显示请求指定的资源，一般用于数据资源的读取，在url末尾可以追加查询字符串，请求的body中只能包含很少数据，依据浏览器和服务器的不同而不同



POST

POST请求会 向指定资源提交数据，请求服务器进行处理，主要用来向服务器新增数据，请求的主体理论上可以包含任意多数据。如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。

post传递数据--content type的理解https://www.cnblogs.com/tugenhua0707/p/8975121.html

  **Content-Type**是指http/https发送信息至服务器时的内容编码类型，contentType用于表明发送数据流的类型，服务器根据编码类型使用特定的解析方式，获取数据流中的数据。

在网络请求中，常用的Content-Type有如下：
text/html, text/plain, text/css, text/javascript, image/jpeg, image/png, image/gif,
application/x-www-form-urlencoded, multipart/form-data, application/json, application/xml 等。



HEAD

与GET方法一样，都是向服务器发出指定资源的请求。<u>但服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。常被用于客户端查看服务器的性能。</u>



PUT

PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。



**PUT和POST**

![image-20210512155140349](/Users/wenxin/Library/Application Support/typora-user-images/image-20210512155140349.png)

PUT和POS都有更改指定URI的语义.但PUT被定义为idempotent（幂等的）的方法，POST则不是.

idempotent的方法:如果一个方法重复执行多次，产生的效果是一样的，那就是idempotent的。<u>也就是说：PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源）</u>

 

DELETE

DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。

 

CONNECT

CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于[SSL](http://itbilu.com/other/relate/N16Uaoyp.html)加密服务器的链接与非加密的HTTP代理服务器的通信。

要求在与代理服务器通信时建立隧道，实现用隧道协议进行tcp通信。主要使用ssl(安全套接层)和tls(传输层安全)协议把通信内容加密后经网络隧道传输 

OPTIONS

 OPTIONS请求：

称为”预检”请求（preflight），在发送跨域请求的时候，先发送个options请求询问服务端是否允许该跨域请求。只有得到肯定答复，浏览器才会发出正式的HttpRequest（GET、POST等）第二次请求；否则就报错，也不会进行第二次请求。

OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用'*'来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的[XMLHttpRequest](http://itbilu.com/javascript/js/VkiXuUcC.html)对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 

![image-20210512152437523](/Users/wenxin/Library/Application Support/typora-user-images/image-20210512152437523.png)

TRACE

TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。

 会在目的服务器端发起一个“回环”诊断，因为客户端在发起一个请求时，这个请求可能要穿过防火墙、代理、网关、或者其它的一些应用程序。这中间的每个节点都可能会修改原始的HTTP请求，TRACE方法允许客户端在最终将请求发送服务器时，它变成了什么样子。由于有一个“回环”诊断，在请求最终到达服务器时，服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文的最终模样。这样客户端就可以查看HTTP请求报文在发送的途中，是否被修改过 



HEAD 

HEAD与GET方法一样，只是不返回报文的主体部分，主要用于确认url的有效性及资源更新的日期时间。判断类型、查看响应中的状态码、测试资源是否被修改过、查看服务器性能 PUT 用来传输文件，在请求报文的主体内容中包含文件内容，保存到请求URL指定的位置，

http1.1的PUT方法自身不带验证机制，任何人都可以请求，上传文件，会有安全问题

 OPTIONS 

查询服务器支持的请求方法



PATCH 

与PUT请求类似，同样用于资源的更新，但有两点不同，一是PATCH一般用于资源的部分更新，而PUT用于资源的整体更新；二是当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已存在的资源进行更新

## 请求消息和响应消息

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：

<u>请求行（request line）、请求头部（header）、空行和 请求数据</u> 四个部分组成。

![img](https://www.runoob.com/wp-content/uploads/2013/11/2012072810301161.png)

请求数据：不在GET方法中使用，而是在POST方法中使用

响应正文：

有这种

![image-20210816112201556](https://tva1.sinaimg.cn/large/008i3skNgy1gtigr281jlj61g80ic79y02.jpg)

和这种

![image-20210816112315501](https://tva1.sinaimg.cn/large/008i3skNgy1gtigsaxn5rj61ss04at9x02.jpg)

网页应用在接收和解释请求消息后服务器会返回一个HTTP响应消息，由四个部分组成，分别是：<u>状态行、消息报头、空行和响应正文</u>。

![img](https://www.runoob.com/wp-content/uploads/2013/11/httpmessage.jpg)

格式如：HTTP-Version Status-Code Reason-Phrase CRLF

其中，HTTP-Version 表示服务器HTTP协议的版本;Status-Code 表示服务器发回的响应状态代码;Reason-Phrase 表示状态代码的文本描述。



## HTTPS

HTTP：是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

HTTPS：是一种在加密信道进行 HTTP 内容传输的协议。是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。（HTTP+SSL/TLS）

**补充** SSL协议**

https://blog.csdn.net/Better2326/article/details/48371241

### 一、SSL是啥？ 

SSL（Secure Socket Layer安全套接层）以及其继承者TSL（Transport Layer Security 传输层安全）是为了网络通信安全 提供安全及数据完整性的一种安全协议。TLS与SSL在[传输层](http://baike.baidu.com/view/239605.htm)对网络连接进行加密。

### 二、SSL具体有啥内容？

SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：

SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。

SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。
  那么SSL的记录协议层和握手协议层到底是工作在什么地方，如果我们单纯的在TCP/IP模型上找的话很难找到，因为TCP/IP模型分四层：应用层，传输层，网络互联层，网络接口层，我们看到SSL协议的底层也就是记录协议层已经工作在了传输层之上了，而握手协议是建立在记录协议层上的，所                                                                                                                                                                                                                                                                                                                以，在四层模型中，我们很难找到他们具体对应的位置，我们要到OSI七层模型中找，我们具体看看7层模型。

二、HTTP与HTTPS有什么区别？

HTTPS协议由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

<u>HTTPS和HTTP的区别主要如下</u>：

\* HTTP 明文传输，数据未加密，安全性较差。https数据传输过程加密

\* 使用 HTTPS 协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用。

\* **HTTP 页面响应速度比 HTTPS 快**，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所共12 个包。（补充：SSL握手https://razeencheng.com/post/ssl-handshake-detail）

\* http 和 https 使用完全不同的连接方式，http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议。端口也不一样，前者是 80，后者是 443。

\* HTTPS 建构在 SSL/TLS 之上的 HTTP 协议，更耗费服务器资源。

**https传输的具体过程**

![HTTP请求的基础知识——HTTP中GET，POST和PUT的区别1](https://res-static.hc-cdn.cn/fms/img/f2195fb940bbbbfba5e7755d63596bce1603778764340)

https://juejin.im/entry/58d7635e5c497d0057fae036

**HTTPS协议的主要作用可以分为两种：一是建立一个信息安全通道，保证数据传输安全；另一种是确认网站的真实性。**

TLS 的完整过程需要三个算法（协议），密钥交互算法，对称加密算法，和消息认证算法

**HTTPS 的整体过程分为证书验证和数据传输阶段**

证书验证阶段：

- 浏览器发起 HTTPS 请求。（ TLS 握手请求）
- 服务端返回 证书(包含服务器公钥S_PuKey)、对称加密算法种类及其他相关信息。
- 客户端验证证书是否合法，不合法提示告警。

数据传输阶段：

- 当证书验证合法后，在本地生成随机数。
- 通过公钥加密随机数，并把加密后的随机数传输到服务端。
- 服务端通过私钥对随机数进行解密。
- 服务端通过客户端传入的随机数构造对称加密算法，之后的数据交互通过对称加密算法进行加解密。（对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法）

服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥。

 常见问题 https://netsecurity.51cto.com/art/201912/607179.htm

**为什么<u>数据传输</u>是用对称加密?**

HTTP的应用场景中通常端与端之间存在大量的交互，非对称加密的加解密效率非常低 

另外，在 HTTPS的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密

Q：HTTPS 的传输过程是怎样的?

A：客户端发起 HTTPS 请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于构造对称加密算法的随机数。

**通过证书中的公钥对随机数进行加密传输到服务端（随机对称密钥），服务端接收后通过私钥解密得到随机对称密钥，之后的数据交互通过对称加密算法进行加解密。**（既有对称加密，也有非对称加密）

Q：为什么需要证书?

A：防止“中间人”攻击，同时可以为网站提供身份证明。

Q：使用 HTTPS 会被抓包吗?

A：会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。

**https对称和非对称详细**   https://www.jianshu.com/p/918d9f517749

##  POST -content type

https://www.jianshu.com/p/065fc0555056

https://juejin.cn/post/6844903607964270599

*POST 几种请求主要包括 application/x-www-form-urlencoded、 multipart/form-data、 application/json、text/xml 四种*

**服务端根据请求头（Request Headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。**

POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。

## `TCP`的可靠传输实现（流量控制，拥塞控制）

**校序重流拥**

* 校验和
  发送的数据包的二进制相加然后取反，**目的是检测数据在传输过程中的任何变化**。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。

* 确认应答+序列号
  TCP给发送的**每一个包进行编号**，接收方**对数据包进行排序**，把有序数据传送给应用层。

* 超时重传
  当TCP**发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段**。如果不能及时收到一个确认，将重发这个报文段。 

* **流量控制**
  **TCP连接的每一方都有固定大小的缓冲空间**，TCP的**接收端只允许发送端发送接收端缓冲区能接纳的数据**。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。 
  **接收方有即时窗口（滑动窗口），随ACK报文发送**

* **拥塞控制** 

  当网络拥塞时，减少数据的发送。
  
  

**流量控制和拥塞控制的区别？**

**拥塞控制**

https://sites.google.com/site/jishutaolun/network/tcp-congestion

https://developer.aliyun.com/article/691978

TCP的拥塞控制主要原理依赖于一个拥塞窗口(cwnd)来控制

## 路由器

路由器是连接两个或多个网络的硬件设备，在网络间起[网关](https://baike.baidu.com/item/网关/98992)的作用，是读取每一个数据包中的地址然后决定如何传送的专用智能性的网络设备。

路由器可以分析各种不同类型网络传来的数据包的目的地址，把非TCP/IP网络的地址转换成TCP/IP地址，或者反之；再根据选定的[路由算法](https://baike.baidu.com/item/路由算法/2709757)把各数据包按最佳路线传送到指定位置。所以路由器可以把非TCP/ IP网络连接到[因特网](https://baike.baidu.com/item/因特网/114119)上。



