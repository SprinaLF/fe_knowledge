# 前端安全

https://juejin.im/entry/598d6eb46fb9a03c3a25d2c1

一、XSS攻击与防御

二、CSRF攻击

三、HTTP劫持与对策

四、界面操作劫持

五、防御手段

https://juejin.im/post/5e16fc706fb9a02fe45805a6  xss  csrf

### XSS(跨站脚本攻击)攻击与防御

https://zhuanlan.zhihu.com/p/26177815

XSS的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。攻击者通过<u>向web页面或者网站的url添加恶意的script(脚本)代码</u>，  用户访问该网站时，执行恶意代码对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据。 

- 比如获取cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的话不存储在数据库中，往往表现为将攻击代码放在url地址的请求参数中，防御的话为cookie设置httpOnly属性，对用户的输入进行检查，进行特殊字符过滤 

- 比如劫持流量实现恶意跳转

  在网页中想办法插入一句像这样的语句：

```js
<script>window.location.href="http://www.baidu.com";</script>
```

​				那么所访问的网站就会被跳转到百度的首页。早在2011年新浪就曾爆出过严重的xss漏洞，导致大量用户自动关		注某个微博号并自动转发某条微博

注入恶意脚本一般包括Javascript，有时也会包含HTML和Flash,共同点为：将一些隐私数据像cookie、session发送给攻击者，将受害者重定向到一个由攻击者控制的网站，

XSS获取用户cookie示例：

示例1.

![image-20210816163840558](https://tva1.sinaimg.cn/large/008i3skNgy1gtipwkkvk0j61kq0skn2d02.jpg)

示例2.

![image-20210816164054052](https://tva1.sinaimg.cn/large/008i3skNgy1gtipyup193j61k60dcq5b02.jpg)

**发生XSS的场景：**

\1. 网站对用户的输入过滤不足，返回给用户的展示结果过滤不足。

\2. 网站的链接地址未经过过滤

为了减轻这些攻击，需要在HTTP头部配上，set-cookie： httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie

**xss攻击种类**

**1、反射型XSS** 

发请求时，XSS代码出现在URL中，提交给服务端。服务端返回的内容，也带上了这段XSS代码。最后浏览器执行XSS代码。

把我们的恶意脚本通过url的方式传递给了服务器，而服务器则只是不加处理的把脚本“反射”回访问者的浏览器而使访问者的浏览器执行相应的脚本。



通常情况是攻击者找到有XSS漏洞的网站，然后构造一个连接，就像这种

**http://www.hasxss.com?x=<script>alert(document.cookie)</script>**

带有攻击效果的链接

然后诱导你点击

通常他们会把链接短链一下迷惑你，就好比

**http://dwz.cn/woshiduanwangzhi**

PS:通常还会加上一句类似 ~你们看看王宝强儿子长得像谁~ 这种标题😓。

然后你点击进去就中招了。

**2、存储型XSS**

存储型和反射型的区别就是，提交的XSS代码会存储在服务器端。这种XSS也是最危险的。

举个例子，我们的网站允许用户设置一段个性签名，会显示在个人主页。

然后用户签名设置为

<script>alert(document.cookie)<script>。(发送给攻击者的服务器)

数据库存储这段代码，然后页面显示出来。

如果这个过程中没有经过任何转义，那么这段html就直接执行了。这样，所有访问你个人主页的用户，就都中招了。



**XSS攻击的防范：**

- 首先是过滤。对诸如<script>、<img>、<a>等标签进行过滤。
- 其次是编码。像一些常见的符号，如<>在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果。
- 最后是限制。通过以上的案例我们不难发现xss攻击要能达成往往需要较长的字符串，因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御。
- 避免使用**eval，new Function**等执行字符串的方法，除非确定字符串和用户输入无关。
- 使用innerHTML，document.write的时候，如果数据是用户输入的，那么需要对关键字符都进行过滤与转义。
- 对于非客户端cookie，比如保存用户凭证的session，务必标识为http only，这样js就获取不到这个cookie值了，安全性得到提高。

​    1、输入检查    对用户的任何输入进行检查、过滤和转义。建立可信任的字符和HTML标签白名单，对于不在白名单的字符或者标签进行过滤或编码。 

​    2、输出检查    服务器的输出也会存在问题，在变量输出到HTML页面时，可以使用编码或者转义的方式来预防XSS攻击。

- 对 HTML 标签及一些特殊符号进行转义

  > 该种方法是一种非常简单的过滤方法，仅仅是通过转义的方式将一些 HTML 标签和属性转义，比如 < 转义成 &lt ;， 这样像<script>xxx</script>的脚本就运行不了。当然简单的过滤方式也就代表很容易就会被绕过。 
  > 另外如果需要使用含有富文本的功能时，使用这样的过滤就会使富文本失去作用。

- 使用白名单、黑名单的方式进行过滤

  > 白名单、黑名单顾名思义是要定义哪些东西是可通过的，哪些东西不可通过。比如常见 <b>、<p>; 、< 等等标签，不可通过的比如 javascript、<a>、<script>、<iframe>、onload 等等一些属性，将其进行转义。 
  > 当然使用该种方法也有自身的缺点，你并不可能穷举出所有元素，也可能会某些元素在黑名单内，但在某些情况它是需要使用的，这就需要我们在设计 XSS 过滤器的时候权衡好，取最合理最适合需求的设计。





### **一、 什么是XSS攻击？**

XSS（Cross-Site Scripting，又称跨站脚本攻击）是一种代码注入攻击，攻击者是通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可以获取用户的敏感信息，比如cookie,sessionID等 ，进而危害数据安全。

### **二、 根据攻击来源，XSS攻击可以分为三类：**

#### **1. 存储型XSS**

- 攻击步骤：攻击者将恶意代码提交到目标网站的数据库中，用户打开网站是，网站服务端将恶意代码从数据库中取出，拼接在HTML中返回浏览器，之后用户浏览器收到响应后解析执行混入其中的恶意代码，恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作。
- 常见于带有用户保存数据的网站功能，比如论坛发帖、商品评价、用户私信等等。

#### **2. 反射型XSS**

- 攻击步骤：攻击者构造出特殊的URL，其中包含恶意代码。当用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回浏览器，之后用户浏览器收到响应后解析执行混入其中的恶意代码，恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作。
- 常见于通过 URL 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。
- 反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

#### **3. DOM型XSS**

- 攻击步骤：攻击者构造出特殊的URL，其中包含恶意代码，用户打开带有恶意代码的URL，用户浏览器打开带有恶意代码的URL，之后用户浏览器收到响应后解析执行，前端JS取出URL中的恶意代码并执行，恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作。
- DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

### **三、 预防XSS攻击：**

防止 HTML 中出现注入；防止 JavaScript 执行时，执行恶意代码。

**1. 预防存储型和反射型 XSS 攻击：**

- 改成纯前端渲染，把代码和数据分隔开。
- 对 HTML 做充分转义。

**2. 预防 DOM 型 XSS 攻击：**

- 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。
- 如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。

**3. 其他XSS攻击防范：**

- Content Security Policy（CSP）
- 输入内容长度控制，增加XSS攻击的难度。
- HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。
- 验证码：防止脚本冒充用户提交危险操作。



### CSRF 跨站请求伪造

https://zhuanlan.zhihu.com/p/114750961

  是一种劫持受信任用户向服务器发送非预期请求的攻击方式。 通常情况下，CSRF攻击时攻击者借助受害者的Cookie骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在未授权的情况下进行操作。

可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。  比如用户登录了一个网站后，立刻在另一个ｔａｂ页面访问量攻击者用来制造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候CSRF就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库，

防御：使用验证码，检查https头部的refer，在请求地址中添加 token 并验证，在 HTTP 头中自定义属性并验证。



**CSRF的防范** 

将cookie设置为HttpOnly（Js获取Cookie 的时候就会跳过HttpOnly = true 的Cookie 记录）

检测Referer：HTTP头部的Referer用来记录HTTP请求的来源地址，一般情况下，来自本站的请求都是合法且安全的，而且对于比较敏感操作，必须设置来源本站，于是通过检测Referer信息，就可以避免此类攻击

设置token
	在请求中放入攻击者无法伪造的东西，从而避免此类攻击，如在http请求中加入随机的token，然后在数据提交时，先进行token验证，如果正确，则继续后续操作，否则阻止继续进行。 

三、HTTP劫持与对策

当我们访问页面的时候，运营商在页面的HTML代码中，插入弹窗、广告等HTML代码，来获取相应的利益。

针对这种情况，最好的解决方式也就是使用HTTPS，加密过后，他们就没法插入广告代码了。

那么对于还没有升级的情况，我们可以努力让影响降到最低。

 

四、界面操作劫持

五、防御手段

**上面列举的例子都不具备实际攻击作用**，因为浏览器厂商，W3C等已经做了很多安全工作，让我们的页面可以安稳的运行起来。但道高一尺魔高一丈，我们要合理运用防护手段，才能让页面不被攻击。

1、HTTP响应头，在响应头可以通过这些字段来提高安全性

- X-Frame-Options 禁止页面被加载进iframe中
- X-XSS-Protection 对于反射型XSS进行一些防御
- X-Content-Security-Policy 这个就比较复杂了，可选项很多，用来设置允许的的资源来源以及对脚本执行环境的控制等。

2、使用HTTPS、使用HTTP ONLY的cookie。cookie的secure字段设置为true

3、GET请求与POST请求，要严格遵守规范，不要混用，不要将一些危险的提交使用JSONP完成。



## 

# 前端性能优化

前端性能优化：细说浏览器渲染的重排与重绘

http://www.imooc.com/article/45936

**大前端性能总结**      https://juejin.im/post/5b025d856fb9a07aa0484e54

# 前端路由原理

https://github.com/fengshi123/blog/blob/master/articles/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%EF%BC%9A%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86.md

## 前端缓存

https://juejin.cn/post/6993358764481085453 (****这个写得好)

https://segmentfault.com/a/1190000020086923

https://www.cnblogs.com/chengxs/p/10396066.html  https://juejin.cn/post/6844903811870375944http   浏览器缓存详细过程

两大类：http缓存和浏览器(本地)缓存

![image-20201119110951909](C:\Users\sprina\AppData\Roaming\Typora\typora-user-images\image-20201119110951909.png)

**http缓存**

​	    当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。

常见的http缓存只能缓存get请求响应的资源，<u>所以后续说的请求缓存都是指GET请求。</u>

http缓存都是从第二次请求开始的：

​	第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304(服务端已经执行了GET，但文件未变化。)，否则服务器会返回新的资源

**http缓存的分类：**
 <u>根据是否需要重新向服务器发起请求来分类，可分为(强制缓存，协商缓存) 根据是否可以被单个或者多个用户使用来分类，可分为(私有缓存，共享缓存)</u> 

<u>强制缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。</u>

下面是强制缓存和协商缓存的一些对比

https://www.jianshu.com/p/1a1536ab01f1

1.强缓存：不会向服务器发送请求，直接从缓存中读取资源，该请求返回200的状态码;

2.协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header<u>通知浏览器从缓存中读取资源</u>；

**都是从客户端缓存中读取资源；区别是强缓存不会发请求，协商缓存会发请求。**

**浏览器缓存过程**

1.浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；

2<u>.下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存</u>，不发请求直接从本地缓存读取该文件，若过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求

3.服务器收到请求后，优先根据**Etag**的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200；

4.如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200

**浏览器本地缓存**

最常用的是cookie、localStroage、sessionStroage、webSql、indexDB。

**1.cookie使用**

用法很简单,可以通过服务端设置，js也可以通过documnet.cookie="名称=值;"（不要忘记以;分割）来设置。
cookie的**值**字符串可以用encodeURIComponent()来保证它不包含任何逗号、分号或空格(cookie值中禁止使用这些值).
cookie一般用做为登陆态保存、密码、个人信息等关键信息保存使用，所以为了安全也是**遵守同源策略原则**的。
**可以通过下面参数具体设置：**
;**path**=path (例如 '/', '/mydir') 如果没有定义，默认为当前文档位置的路径。
;**domain**=domain (例如 'example.com'， 'subdomain.example.com') 如果没有定义，默认为当前文档位置的路径的域名部分。与早期规范相反的是，在域名前面加 . 符将会被忽视，因为浏览器也许会拒绝设置这样的cookie。如果指定了一个域，那么子域也包含在内。
;**max-age=**max-age-in-seconds (例如一年为60*60*24*365)
;**expires**=date-in-GMTString-format 如果没有定义，cookie会在对话结束时过期这个值的格式参见Date.toUTCString()
;**secure** (cookie只通过https协议传输)
;**HttpOnly** 限制web页面程序的browser端script程序读取cookie

**缺点**
容量有限制，不能超过4kb
在请求头上带着数据安全性差

**2.localStorage和sessionStorage使用**

<u>html5新增本地存储</u>，

localStorage生命周期是永久，除非主动清除，否则这些信息将**永远存在**。存放数据大小为一般为5MB

sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。也是**遵守同源策略原则**的

```
// 1、保存数据到本地
// 第一个参数是保存的变量名，第二个是赋给变量的值
localStorage.setItem('key', 'value');
//复杂类型储存需要**利用JSON.stringify**将对象转换成字符串；
//利用**JSON.parse**将字符串转换成对象
// 2、从本地存储获取数据
localStorage.getItem('key');
// 3、从本地存储删除某个已保存的数据
localStorage.removeItem('key');
// 4、清除所有保存的数据
localStorage.clear();
```

### 3. Web SQL

WebSQL是前端的一个独立模块，是web存储方式的一种，我们调试的时候会经常看到，只是一般很少使用。并且，当前只有谷歌支持，ie和火狐均不支持。
主要方法：

1.openDatabase：这个方法使用现有的数据库或者新建的数据库创建一个数据库对象。
2.transaction：这个方法让我们能够控制一个事务，以及基于这种情况执行提交或者回滚。
3.executeSql：这个方法用于执行实际的 SQL 查询。

### 4.indexDB

<u>浏览器提供的本地数据库</u>，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库

https://juejin.im/post/6844903764566999054

### 浏览器缓存

![image](https://user-gold-cdn.xitu.io/2019/1/21/1686e2735297a596?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

![image](https://user-gold-cdn.xitu.io/2019/1/21/1686e2735267bebb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

简单来说,浏览器缓存其实就是浏览器保存通过HTTP获取的所有资源,是浏览器将网络资源存储在本地的一种行为。

![image-20201118192540761](C:\Users\sprina\AppData\Roaming\Typora\typora-user-images\image-20201118192540761.png)

**三级缓存原理 (访问缓存优先级)**

1. 先在内存中查找,如果有,直接加载。
2. 如果内存中不存在,则在硬盘中查找,如果有直接加载。
3. 如果硬盘中也没有,那么就进行网络请求。
4. 请求获取的资源缓存到硬盘和内存。

**浏览器缓存的优点**

1.减少了冗余的数据传输

2.减少了服务器的负担，提升网站的性能

3.加快了客户端加载网页的速度

**补充**

### DNS缓存

有dns的地方,就有缓存。浏览器、操作系统、Local DNS、根域名服务器，它们都会对DNS结果做一定程度的缓存。

DNS查询过程如下:

1. 首先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。
2. 读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。
3. 查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。
4. 如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。

### CDN 优势

1. CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低。
2. 大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源服务器的负载

# 前端工程化

## Webpack

原理，为什么可以import css文件

# 前端发展

### Vue3.0新增了什么

### ES6,7,9