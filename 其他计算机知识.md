## 网络模型

![img](https://images2018.cnblogs.com/blog/137084/201805/137084-20180525143809658-1611041911.jpg)



### **每层的协议？



## 三次握手

![img](https://camo.githubusercontent.com/92800a8405ffab35ba53a6fc2aa664385be4ab24/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323434383735322d363030663232613930323432623536652e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

https://juejin.im/post/5d9c284b518825095879e7a5

1 主机A向主机B发送一个含有同步序列号的标志位的数据段给主机B ,向B请求建立连接,通过这个数据段,
 主机A告诉主机B 两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我.
 2 主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:     我已经收到你的请求了,你可以传输数据了;你要用哪佧序列号作为起始数据段来回应我
 3 主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B 的数据段:"我已收到回复,我现在要开始传输实际数据了

特点
 没有应用层的数据
 SYN这个标志位只有在TCP建产连接时才会被置1
 握手完成后SYN标志位被置0

### 为什么需要三次握手

<u>防止已失效的连接请求报文段突然又传送到了服务端，产生错误</u>

“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，延误到连接释放以后的某个时间到达server。server收到后误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。

假设不采用“三次握手”，只要server发出确认，新的连接就建立了。client并没有发出建立连接的请求，不会理睬server的确认，也不会向server发送数据。但server却以为新连接已建立，并一直等待client发来数据。

这样，server的很多资源就白白浪费掉了。

采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。防止server端一直等待，浪费资源。

## 四次挥手

1 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求
 2 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1
 3 由B 端也提出反方向的关闭请求,将FIN置1
 4 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.

**为什么需要四次**

因为TCP是全双工通信的

   （1）第一次

​     主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。

​    （2）第二次

​     **被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）**。

   （3）第三次挥手

​    **被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）**。

   （4）第四挥手

​    如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。

 由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础

## tcp和udp区别

https://blog.csdn.net/sifanchao/article/details/82285018?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

**tcp**

​	面向连接：      三次握手，四次挥手

​	可靠传输：     序列号 确认应答 超时重传 拥塞控制

​	面向字节流

**udp**

​	无连接：		知道对端的IP和端口号就直接进行传输, 不需要建立连接。

​	不可靠：		没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息。
​	面向数据报：不能够灵活的控制读写数据的次数和数量，应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并。

### `TCP`的可靠传输怎么实现（流量控制，拥塞控制）

**校序重流拥**

* 校验和
  发送的数据包的二进制相加然后取反，**目的是检测数据在传输过程中的任何变化**。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。
* 确认应答+序列号
  TCP给发送的**每一个包进行编号**，接收方**对数据包进行排序**，把有序数据传送给应用层。
* 超时重传
  当TCP**发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段**。如果不能及时收到一个确认，将重发这个报文段。 
* 流量控制
  **TCP连接的每一方都有固定大小的缓冲空间**，TCP的**接收端只允许发送端发送接收端缓冲区能接纳的数据**。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。 
  **接收方有即时窗口（滑动窗口），随ACK报文发送**
* 拥塞控制
  当网络拥塞时，减少数据的发送。
  **发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小**
  **慢启动、拥塞避免、拥塞发送、快速恢复**

## HTTPS

HTTP：是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

HTTPS：是一种在加密信道进行 HTTP 内容传输的协议。是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。（HTTP+SSL/TLS）

二、HTTP与HTTPS有什么区别？

HTTPS协议由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

<u>HTTPS和HTTP的区别主要如下</u>：

\* HTTP 明文传输，数据未加密，安全性较差。https数据传输过程加密

\* 使用 HTTPS 协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用。

\* **HTTP 页面响应速度比 HTTPS 快**，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所共12 个包。（补充：SSL握手https://razeencheng.com/post/ssl-handshake-detail）

\* http 和 https 使用完全不同的连接方式，http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议。端口也不一样，前者是 80，后者是 443。

\* HTTPS 建构在 SSL/TLS 之上的 HTTP 协议，更耗费服务器资源。

**https传输的具体过程**

https://juejin.im/entry/58d7635e5c497d0057fae036

**HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种是确认网站的真实性。**

TLS 的完整过程需要三个算法（协议），密钥交互算法，对称加密算法，和消息认证算法

**HTTPS 的整体过程分为证书验证和数据传输阶段**

证书验证阶段：

- 浏览器发起 HTTPS 请求。（ TLS 握手请求）
- 服务端返回 证书(包含服务器公钥S_PuKey)、对称加密算法种类及其他相关信息。
- 客户端验证证书是否合法，不合法提示告警。

数据传输阶段：

- 当证书验证合法后，在本地生成随机数。
- 通过公钥加密随机数，并把加密后的随机数传输到服务端。
- 服务端通过私钥对随机数进行解密。
- 服务端通过客户端传入的随机数构造对称加密算法，之后的数据交互通过对称加密算法进行加解密。（对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法）

服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥。

 常见问题 https://netsecurity.51cto.com/art/201912/607179.htm

**为什么<u>数据传输</u>是用对称加密?**

HTTP的应用场景中通常端与端之间存在大量的交互，非对称加密的加解密效率非常低 

另外，在 HTTPS的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密

Q：HTTPS 的传输过程是怎样的?

A：客户端发起 HTTPS 请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于构造对称加密算法的随机数。

**通过证书中的公钥对随机数进行加密传输到服务端（随机对称密钥），服务端接收后通过私钥解密得到随机对称密钥，之后的数据交互通过对称加密算法进行加解密。**（既有对称加密，也有非对称加密）

Q：为什么需要证书?

A：防止“中间人”攻击，同时可以为网站提供身份证明。

Q：使用 HTTPS 会被抓包吗?

A：会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。

**https对称和非对称详细**   https://www.jianshu.com/p/918d9f517749

## HTTP请求方法介绍

**get** **和post的区别**

· get用来获取数据，post用来提交数据 

· get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节），而post无限制。 

· get请求的数据会附加在url之 ，以 " ？ "分割url和传输数据，多个参数用 "&"连接，而post请求会把请求的数据放在http请求体中。 

· get是明文传输，post是放在请求体中，但是开发者可以通过抓包工具看到，也相当于是明文的。 

· get请求会保存在浏览器历史记录中，还可能保存在web服务器的日志中

不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同响应。

GET

会显示请求指定的资源。一般GET方法应该只用于数据读取，而不应当用于会产生副作用的非幂等的操作中。

GET方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。

HEAD

HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。



POST

POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。

 

PUT

PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。

 

DELETE

DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。

 

CONNECT

CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于[SSL](http://itbilu.com/other/relate/N16Uaoyp.html)加密服务器的链接与非加密的HTTP代理服务器的通信。

 

OPTIONS

OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用'*'来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的[XMLHttpRequest](http://itbilu.com/javascript/js/VkiXuUcC.html)对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许

 

TRACE

TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。

 

GET 

GET请求会显示请求指定的资源，一般用于数据资源的读取，在url末尾可以追加查询字符串，请求的body中只能包含很少数据，依据浏览器和服务器的不同而不同

POST 

主要用来向服务器新增数据，请求的主体理论上可以包含任意多数据

HEAD 

HEAD与GET方法一样，只是不返回报文的主体部分，主要用于确认url的有效性及资源更新的日期时间。判断类型、查看响应中的状态码、测试资源是否被修改过、查看服务器性能 PUT 用来传输文件，在请求报文的主体内容中包含文件内容，保存到请求URL指定的位置，http1.1的PUT方法自身不带验证机制，任何人都可以请求，上传文件，会有安全问题 DELETE 删除服务器上某个资源 OPTIONS 

查询服务器支持的请求方法 TRACE 可以对请求消息的传输路径进行追踪 CONNECT 

要求在与代理服务器通信时建立隧道，实现用隧道协议进行tcp通信。主要使用ssl(安全套接层)和tls(传输层安全)协议把通信内容加密后经网络隧道传输 PATCH 

与PUT请求类似，同样用于资源的更新，但有两点不同，一是PATCH一般用于资源的部分更新，而PUT用于资源的整体更新；二是当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已存在的资源进行更新

## 简述所有状态码 

https://www.runoob.com/http/http-status-codes.html

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：

请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。

 

网页应用在接收和解释请求消息后服务器会返回一个HTTP响应消息，而HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文

格式如：HTTP-Version Status-Code Reason-Phrase CRLF

其中，HTTP-Version 表示服务器HTTP协议的版本;Status-Code 表示服务器发回的响应状态代码;Reason-Phrase 表示状态代码的文本描述。

而状态码由3个数字组成，第一个数字定义的是响应的类别，有5种可能取值：

 

1XX信息性状态码（Informational）服务器正在处理请求

2XX成功状态码（Success）请求已正常处理完

3XX重定向状态码（Redirection）需要进行额外操作以完成请求

4XX客户端错误状态码（Client Error）客户端原因导致服务器无法处理请求

5XX服务器错误状态码（Server Error）服务器原因导致处理请求出错

 

常见状态代码、状态描述及说明：

200 OK ：客户端请求成功

204 No Content  表示请求已成功处理，但是没有内容返回（就应该没有内容返回的状况）

206 Partial Content  表示服务器已经完成了部分GET请求

301 Moved Permanently  永久重定向，表示请求的资源已经永久的搬到了其他位置

302 Found 临时重定向，表示请求的资源临时搬到了其他位置

303 See Other 表示请求资源存在另一个URI，应使用GET定向获取请求资源

304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。

400 Bad Request 客户端请求有语法错误，不能被服务器所理解

401 Unauthorized 表示发送的请求需要有HTTP认证信息或者是认证失败了（请求未经授权）

403 Forbidden  表示对请求资源的访问被服务器拒绝了

404 Not Found 表示服务器找不到你请求的资源

500 Internal Server Error 表示服务器执行请求的时候出错了

502    作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个**无效的响应**

503 Service Unavailable 表示服务器超负载或正停机维护，无法处理请求，一段时间后可能恢复正常

504      充当网关或代理的服务器，**未及时从远端服务器获取请求**

## cookie session



## 路由器

路由器是连接两个或多个网络的硬件设备，在网络间起[网关](https://baike.baidu.com/item/网关/98992)的作用，是读取每一个数据包中的地址然后决定如何传送的专用智能性的网络设备。

路由器可以分析各种不同类型网络传来的数据包的目的地址，把非TCP/IP网络的地址转换成TCP/IP地址，或者反之；再根据选定的[路由算法](https://baike.baidu.com/item/路由算法/2709757)把各数据包按最佳路线传送到指定位置。所以路由器可以把非TCP/ IP网络连接到[因特网](https://baike.baidu.com/item/因特网/114119)上。



# 操作系统

## 进程线程区别

进程是运行中的程序，线程是进程的内部的一个执行序列

**进程是资源分配的最小单位，线程是CPU调度的最小单位**

进程间切换代价大，线程间切换代价小

进程拥有资源多，线程拥有资源少

多个线程共享进程的资源

- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）

### 进程间通信

**管道**：

​	匿名管道和命名管道

**消息队列**

**共享内存**

**信号量**

​	本质就是一个计数器，用来实现进程之间的互斥与同步

**Socket**

​	这个就是我们一直在用的进程间的通信方式了，如我们的微信APP跟微信服务器通信，其实就是使用的Socket套接字进行通信的。

## CPU调度算法

![img](https://img-blog.csdn.net/20180104165256397?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjkyODc5NzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### cpu内存管理

传统上：

​	连续分配

​	非连续分配：分页，分段

虚拟内存：

​	基于局部性原理，将程序的一部分装入内存，其余部分留在外存，便可启动程序执行。执行过程中内存没有的再调入内存，然后继续执行程序。  另一方面，操作系统将内存中暂时不用的内容换出 到外存上（腾出空间）       显得系统好像提供了一个比实际内存大得多的存储器，称为虚拟存储器。

## Linux

**VM**

*虚拟机*,   指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。

1安装VMware和centOS      2安装Xshell

3. Linx下安装并测试JDK,tomcat,Mysql        4. 部署项目  传war包



**安装VMware**

​	VMware Workstation允许一台真实的电脑在一个[操作系统](https://zh.wikipedia.org/wiki/作業系統)中同时开启并运行数个操作系统，其它VMware产品帮助在多个宿主电脑之间管理或移植VMware虚拟机。

![image-20200704144944237](C:\Users\sprina\AppData\Roaming\Typora\typora-user-images\image-20200704144944237.png)

**安装centOS**

​	Linux发行版之一

![image-20200704145018174](C:\Users\sprina\AppData\Roaming\Typora\typora-user-images\image-20200704145018174.png)

![image-20200704145027539](C:\Users\sprina\AppData\Roaming\Typora\typora-user-images\image-20200704145027539.png)

**安装XShell终端**(远程操控)

Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。**可以非常方便的对linux主机进行远程管理**

​	进入Xshell的界面之后连接上Linux服务器

​	**ls命令**: 显示有哪些文件

![img](https://img-blog.csdn.net/20170212222411839?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzA1ODYxOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

我们已经知道文件有哪些后需要知道如何进入我们想要进入的文件，在windows这种图形化的系统下我们可以使用双击这种方式打开我们需要打开的文件，在Xshell中我们需要使用的是：**cd 命令**，默认是在根节点root下面：

　　需要进入的是usr文件的local文件使用：cd /usr/local，来进入，这个时候我们就显示已经进入了local这个文件下面，需要注意的是在root根目录下进入其他文件时需要在最前面加上斜线“/”，在其他任何二级甚至多级目录下都是可以不加直接进入的。

　　有进入同样就有返回，需要返回的时候我们需要使用：cd ../ 这个命令，同样我们也可以在../之后加上我们需要进入的上级文件目录就可以直接进入了



　　在接下来就是如何编辑文件和查看文件了，假如现在local目录下存在host.xml文件，我们需要编辑或者查看它。**查看的命令是cat host.xml**；**编辑的命令是vi host.xml**，然后按下i，进入修改模式，要不然就只是看，如果我们突然不想修改时，按下ESC 然后在命令行中写下 :q!   然后回车就接触编辑，如果我们是编辑完了需要保存，也需要按下ESC，然后输入 :wq 回车。

　　**总结一下就是：编辑文件 vi，按下i进行编辑   保存结束编辑 ESC :wq 回车   不保存结束编辑 ESC :q! 回车**

![img](https://img-blog.csdn.net/20170212223449713?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzA1ODYxOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

　　在Linux系统下执行文件我们需要使用的的 ./文件名.sh，假如我们需要执行host.sh文件，我们需要进入文件所在目录接着执行即可

**安装   jdk   Tomcat   mysql**

**tomcat 中发布项目**

### Linux终端常用命令

cd 切换目录

pwd      (print work directory)      查看当前所在目录

ls       （list）                   列出当前目录的文件

cat 文件名               显示该文件内的所有内容

 rm    删除    

mv    移动和重命名文件

cp     复制文件

vim   编辑文件 （linux中的编辑器）

​	：wq,即write and quit,此种退出方法=保存并退出



**本地文件上传到Linux服务器：**

​	scp命令

**xshell软件里的xftp程序：**

​		点击xshell软件上的xftp图标（前提xftp已经下载好）  然后就可以互传文件了

一：运行 apt install lrzsz 下载程序

第二步：从Windows上传文件到服务器
运行 rz

弹出文件选择窗口选择文件等待上传完成

第三步：从服务器下载文件到Windows服务器
运行 sz 【your file name】

弹出文件选择窗口选择要下载到的路径即可

## Git

git init  重要   第一次使用git，配置用户信息

配置用户名：git config --global user.name "your name";
配置邮箱：git config --global user.email "youremail@github.com";

git remote add origin https://gitee.com/tianjingang/server.git//将本地与远程关联

从远程git仓库复制项目：git clone 仓库地址

创建新分支 git checkout -b <branchName>

git branch 查看本地
git branch -r 查看远程分支
git branch -a 查看本地和远程分支

提交代码：
   git pull 					拉取分支与本地对比
   git add .     				提交工作区所有文件到暂存区
   git commit -am " "    将暂存区中的文件提交到本地仓库中
   git push origin master      

注意：

​	*git commit --amend*    提交过代码之后，发现一个地方改错了，你下次提交时不想保留上一次的记录；或者你上一次的commit message的描述有误，这时候你可以使用接下来的这个命令：git commit --amend。

提供了最后一次commit的反悔。但是**对于历史提交呢，就必须使用rebase了**。

**修改commit详细** https://blog.csdn.net/ds_Yang/article/details/106599538  

  git pull命令之后git如上报错，解决步骤，可以不管(直接下面3,4步)：

//1.按键盘字母 i 进入insert模式

//2.修改最上面那行黄色合并信息,可以不修改

//3.按键盘左上角"Esc"

//4.输入":wq",注意是冒号+wq,按回车键即可

拉取远程分支（同步远程代码）
git fetch upstream 		  拉取仓库下所有分支：
 git checkout master       git merge upstream/master   把上游的远程代码合并到本地的 master分支 
本地master就同步到最新版了。 git push 推到远程



git log之后，可以看到你之前提交过的git历史：

![img](https://pic1.zhimg.com/80/v2-0d0a335a3a87091c40ce138b8be1a9f0_1440w.jpg)

### Git-Rebase

https://cloud.tencent.com/developer/news/231201

https://www.cnblogs.com/kidsitcn/p/5339382.html

**Rebase 场景一：合并多次提交纪录**

​	合并最近的 4 次提交纪录，执行：

```
git rebase -i HEAD~4
```

**Rebase 场景二：让分支合并记录变简洁**

​	`merge` 的信息污染了 `commit` 记录，想要保持一份干净的 `commit`，怎么办呢？这时候，`git rebase` 就派上用场了。

## Node.js

https://www.nodebeginner.org/index-zh-cn.html

JavaScript最早是运行在浏览器中

Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。**是 V8 引擎解析的**

要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。

除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。

因此，Node.js事实上既是一个运行时环境，同时又是一个库。

使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个**HTTP服务器**

## 数据库

### 事务的ACID特性

- Atomicity（原子性）：一个事务中的所有操作，或者全部完成，或者全部不完成,不可分割。事务在执行过程中发生错误，会被[回滚](https://zh.wikipedia.org/wiki/回滚_(数据管理))（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- Consistency（一致性）：在**事务开始之前和事务结束以后，数据库的完整性没有被破坏**。这表示写入的资料必须完全符合所有的预设[约束](https://zh.wikipedia.org/wiki/数据完整性)、[触发器](https://zh.wikipedia.org/wiki/触发器_(数据库))、[级联回滚](https://zh.wikipedia.org/wiki/级联回滚)等。[[1\]](https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1)
- Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性**可以防止多个事务并发执行时由于交叉执行而导致数据的不一致**。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失

## react native

