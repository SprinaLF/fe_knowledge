## 网络模型

![img](https://images2018.cnblogs.com/blog/137084/201805/137084-20180525143809658-1611041911.jpg)



### **每层的协议？

https://blog.csdn.net/qq_22238021/article/details/80279001

![这里写图片描述](https://img-blog.csdn.net/20170822224933262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2lsZW5jZU9P/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

OSI七个层次的功能：

物理层

为数据链路层提供物理连接，在其上串行传送比特流，即所传送数据的单位是比特。此外，该层中还具有确定连接设备的电气特性和物理特性等功能。 
数据链路层

负责在网络节点间的线路上通过检测、流量控制和重发等手段，无差错地传送以帧为单位的数据。为做到这一点，在每一帧中必须同时带有同步、地址、差错控制及流量控制等控制信息。 
网络层

为了将数据分组从源（源端系统）送到目的地（目标端系统），网络层的任务就是选择合适的路由和交换节点，使源的传输层传下来的分组信息能够正确无误地按照地址找到目的地，并交付给相应的传输层，即完成网络的寻址功能。 
传输层

传输层是高低层之间衔接的接口层。数据传输的单位是报文，当报文较长时将它分割成若干分组,然后交给网络层进行传输。传输层是计算机网络协议分层中的最关键一层，该层以上各层将不再管理信息传输问题。 
会话层

该层对传输的报文提供同步管理服务。在两个不同系统的互相通信的应用进程之间建立、组织和协调交互。例如，确定是双工还是半双工工作。 
表示层

该层的主要任务是把所传送的数据的抽象语法变换为传送语法，即把不同计算机内部的不同表示形式转换成网络通信中的标准表示形式。此外，对传送的数据加密（或解密）、正文压缩（或还原）也是表示层的任务。 
应用层

该层直接面向用户，是OSI中的最高层。它的主要任务是为用户提供应用的接口，即提供不同计算机间的文件传送、访问与管理，电子邮件的内容处理，不同计算机通过网络交互访问的虚拟终端功能等。

## 三次握手

![img](https://camo.githubusercontent.com/92800a8405ffab35ba53a6fc2aa664385be4ab24/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323434383735322d363030663232613930323432623536652e6a70673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

https://juejin.im/post/5d9c284b518825095879e7a5

1 主机A向主机B发送一个含有同步序列号的标志位的数据段给主机B ,向B请求建立连接,通过这个数据段,
 主机A告诉主机B 两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我.
 2 主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:     我已经收到你的请求了,你可以传输数据了;你要用哪佧序列号作为起始数据段来回应我
 3 主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B 的数据段:"我已收到回复,我现在要开始传输实际数据了

特点
 没有应用层的数据
 SYN这个标志位只有在TCP建产连接时才会被置1
 握手完成后SYN标志位被置0

### 为什么需要三次握手

<u>防止已失效的连接请求报文段突然又传送到了服务端，产生错误</u>

“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，延误到连接释放以后的某个时间到达server。server收到后误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。

假设不采用“三次握手”，只要server发出确认，新的连接就建立了。client并没有发出建立连接的请求，不会理睬server的确认，也不会向server发送数据。但server却以为新连接已建立，并一直等待client发来数据。

这样，server的很多资源就白白浪费掉了。

采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。防止server端一直等待，浪费资源。

## 四次挥手

1 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求
 2 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1
 3 由B 端也提出反方向的关闭请求,将FIN置1
 4 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.

**为什么需要四次**

因为TCP是全双工通信的

   （1）第一次

​     主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。

​    （2）第二次

​     **被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）**。

   （3）第三次挥手

​    **被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）**。

   （4）第四挥手

​    如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。

 由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础

## tcp和udp区别

https://blog.csdn.net/sifanchao/article/details/82285018?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

**tcp**

​	面向连接：      三次握手建立连接，四次挥手断开连接

​	可靠传输：     序列号 确认应答 超时重传 拥塞控制

​	面向字节流

**udp**

​	无连接：		知道对端的IP和端口号就直接进行传输, 不需要建立连接。

​	不可靠(尽最大努力交付)：		没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息。
​	面向数据报：不能够灵活的控制读写数据的次数和数量，发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不会拆分, 也不会合并。

​    

### `TCP`的可靠传输怎么实现（流量控制，拥塞控制）

**校序重流拥**

* 校验和
  发送的数据包的二进制相加然后取反，**目的是检测数据在传输过程中的任何变化**。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。
  
* 确认应答+序列号
  TCP给发送的**每一个包进行编号**，接收方**对数据包进行排序**，把有序数据传送给应用层。
  
* 超时重传
  当TCP**发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段**。如果不能及时收到一个确认，将重发这个报文段。 
  
* 流量控制
  **TCP连接的每一方都有固定大小的缓冲空间**，TCP的**接收端只允许发送端发送接收端缓冲区能接纳的数据**。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。 
  **接收方有即时窗口（滑动窗口），随ACK报文发送**
  
* 拥塞控制 
  
  当网络拥塞时，减少数据的发送。

**拥塞控制**

https://sites.google.com/site/jishutaolun/network/tcp-congestion

https://developer.aliyun.com/article/691978

TCP的拥塞控制主要原理依赖于一个拥塞窗口(cwnd)来控制

## DNS

DNS解析**流程**分为**递归查询**和**迭代查询**，递归查询是以本地名称服务器为中心查询， 递归查询是默认方式，迭代查询是以DNS客户端，也就是客户机器为中心查询

![img](https://images2015.cnblogs.com/blog/464291/201707/464291-20170703113844956-354755333.jpg)

## HTTP

超文本传输协议（HTTP, HyperText Transfer Protocol）

**无状态**的协议，它位于[OSI七层模型](http://itbilu.com/nodejs/core/VkcdcFq9.html#OSI)的传输层。HTTP客户端会根据需要构建合适的HTTP请求方法，而HTTP服务器会根据不同的HTTP请求方法做出不同的响应。

**补充**:  **如何理解HTTP协议的 “无连接，无状态” 特点？**

**无连接的含义 ** https://segmentfault.com/a/1190000015821798

<u>是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到应答后，即断开连接。这种方式可以节省传输时间。</u>

**无状态**指协议<u>对于事务处理没有记忆能力</u>，服务器不知道客户端什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给发送数据过来，但是，发送完不会记录任何信息。

缺少状态意味着如果后续处理需要前面的信息，则必须重传，这样可能导致每次连接传送的数据量增大。

HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复信息。

客户端与服务器进行动态交互的 Web 应用程序出现后，<u>HTTP 无状态的特性严重阻碍了这些应用程序的实现</u>，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。<u>于是，两种用于保持 HTTP 连接状态的技术： Cookie，Session。</u>

**HTTP发展**

https://juejin.cn/post/6844903923136856078



### cookie session

**Cookie可以保持登录信息到用户下次与服务器的会话，换句话说，下次访问同一网站时，用户会发现不必输入用户名和密码就已经登录了**（当然，不排除用户手工删除Cookie）。而还有一些Cookie在用户退出会话的时候就被删除了，这样可以有效保护个人隐私。

Cookies 最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是 Cookies 的功用。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入 Cookies，以便在最后付款时提取信息。

**与 Cookie 相对的一个解决方案是 Session，通过服务器保持状态的。**

当客户端访问服务器时，服务器根据需求设置 Session，将会话信息保存在服务器上，同时将标示 Session 的 SessionId 传递给客户端浏览器，浏览器将这个 SessionId 保存在内存中，我们称之为无过期时间的 Cookie。浏览器关闭后，这个 Cookie 就会被清掉，它不会存在于用户的 Cookie 临时文件。

以后浏览器每次请求都会额外加上这个参数值，服务器会根据这个 SessionId，就能取得客户端的数据信息。

如果客户端浏览器意外关闭，服务器保存的 Session 数据不是立即释放，此时数据还会存在，只要我们知道那个 SessionId，就可以继续通过请求获得此 Session 的信息，因为此时后台的 Session 还存在，当然我们可以设置一个 Session 超时时间，一旦超过规定时间没有客户端请求时，服务器就会清除对应 SessionId 的 Session 信息。

\1. HTTP版本与HTTP请求方法

http发展 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP

在HTTP的发展过程中，出现了很多HTTP版本，其中的大部分协议都是向下兼容的。在进行HTTP请求时，客户端在请求时会告诉服务器它采用的协议版本号，而服务器则会在使用相同或者更早的协议版本进行响应。

HTTP/0.9

最初版本的HTTP协议并没有版本号，后来它的版本号被定位在 0.9 以区分后来的版本。

**单行指令**，以唯一可用方法[`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET)开头，其后跟目标资源的路径（一旦连接到服务器，协议、服务器、端口号这些都不是必须的）。

```html
GET /mypage.html
```

在HTTP通讯也没有指定版本号，也不支持请求头信息。客户端向服务器传递信息的能力非常有限。

响应也极其简单的：只包含响应文档本身。

```html
<HTML>
这是一个非常简单的HTML页面
</HTML>
```

跟后来的版本不同，HTTP/0.9 的响应内容并不包含HTTP头，这意味着只有HTML文件可以传送，无法传输其他类型的文件；也没有状态码或错误代码：一旦出现问题，一个特殊的包含问题描述信息的HTML文件将被发回，供人们查看。

HTTP/1.0

这个版本是第一个在HTTP通讯中指定版本号的协议版本，HTTP/1.0至今仍被广泛采用，特别是在代理服务器中。

支持：GET、POST、HEAD三种HTTP请求方法。

HTTP/1.1 8种方法

HTTP/1.1是当前正在使用的版本。该版本默认采用持久连接，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。

HTTP/1.1新增了：OPTIONS、PUT、DELETE、TRACE、CONNECT五种HTTP请求方法。

HTTP/2

HTTP/2通过支持请求与相应的多路重用来减少延迟，通过压缩HTTP头字段将协议开销降到最低，同时增加了对请求优先级和服务器端推送的支持。新一代的 HTTP/2 协议的支持需以 HTTPS 为基础。

HTTP/1.1之后增加的方法

在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法：

PATCH

PATCH方法出现的较晚，它在2010年的[RFC 5789](http://tools.ietf.org/html/rfc5789)标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：

但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。

当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。



## HTTP请求方法介绍

**get** **和post的区别**

· get用来获取数据，post用来提交数据 

· get参数有长度限制（受限于url长度，具体的数值取决于浏览器和服务器的限制，最长2048字节），post无限制。 

· get请求的数据会附加在url之 ，以 " ？ "分割url和传输数据，多个参数用 "&"连接，数据在URL中可以看到。

而post请求会把请求的数据放在http请求体中。 

· get是明文传输，post是放在请求体中，但是开发者可以通过抓包工具看到，也相当于是明文的。 

· get请求会保存在浏览器历史记录中，还可能保存在web服务器的日志中

 get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。

不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同响应。

GET

会显示请求指定的资源。一般GET方法应该只用于数据读取，而不应当用于会产生副作用的非幂等的操作中。

GET方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。

HEAD

HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。



POST

POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。

 

PUT

PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。

 

DELETE

DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。

 

CONNECT

CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于[SSL](http://itbilu.com/other/relate/N16Uaoyp.html)加密服务器的链接与非加密的HTTP代理服务器的通信。

 

OPTIONS

 OPTIONS请求：

称为”预检”请求（preflight），在发送跨域请求的时候，先发送个options请求询问服务端是否允许该跨域请求。只有得到肯定答复，浏览器才会发出正式的HttpRequest（GET、POST等）第二次请求；否则就报错，也不会进行第二次请求。

OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用'*'来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的[XMLHttpRequest](http://itbilu.com/javascript/js/VkiXuUcC.html)对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许

TRACE

TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。

 

GET 

GET请求会显示请求指定的资源，一般用于数据资源的读取，在url末尾可以追加查询字符串，请求的body中只能包含很少数据，依据浏览器和服务器的不同而不同

POST 

主要用来向服务器新增数据，请求的主体理论上可以包含任意多数据

HEAD 

HEAD与GET方法一样，只是不返回报文的主体部分，主要用于确认url的有效性及资源更新的日期时间。判断类型、查看响应中的状态码、测试资源是否被修改过、查看服务器性能 PUT 用来传输文件，在请求报文的主体内容中包含文件内容，保存到请求URL指定的位置，http1.1的PUT方法自身不带验证机制，任何人都可以请求，上传文件，会有安全问题 DELETE 删除服务器上某个资源 OPTIONS 

查询服务器支持的请求方法 TRACE 可以对请求消息的传输路径进行追踪 CONNECT 

要求在与代理服务器通信时建立隧道，实现用隧道协议进行tcp通信。主要使用ssl(安全套接层)和tls(传输层安全)协议把通信内容加密后经网络隧道传输 PATCH 

与PUT请求类似，同样用于资源的更新，但有两点不同，一是PATCH一般用于资源的部分更新，而PUT用于资源的整体更新；二是当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已存在的资源进行更新

## HTTPS

HTTP：是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

HTTPS：是一种在加密信道进行 HTTP 内容传输的协议。是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。（HTTP+SSL/TLS）

**补充** SSL协议**

https://blog.csdn.net/Better2326/article/details/48371241

### 一、SSL是啥？ 

SSL（Secure Socket Layer安全套接层）以及其继承者TSL（Transport Layer Security 传输层安全）是为了网络通信安全 提供安全及数据完整性的一种安全协议。TLS与SSL在[传输层](http://baike.baidu.com/view/239605.htm)对网络连接进行加密。

### 二、SSL具体有啥内容？

SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：

SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。

SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。
  那么SSL的记录协议层和握手协议层到底是工作在什么地方，如果我们单纯的在TCP/IP模型上找的话很难找到，因为TCP/IP模型分四层：应用层，传输层，网络互联层，网络接口层，我们看到SSL协议的底层也就是记录协议层已经工作在了传输层之上了，而握手协议是建立在记录协议层上的，所                                                                                                                                                                                                                                                                                                                以，在四层模型中，我们很难找到他们具体对应的位置，我们要到OSI七层模型中找，我们具体看看7层模型。

二、HTTP与HTTPS有什么区别？

HTTPS协议由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

<u>HTTPS和HTTP的区别主要如下</u>：

\* HTTP 明文传输，数据未加密，安全性较差。https数据传输过程加密

\* 使用 HTTPS 协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用。

\* **HTTP 页面响应速度比 HTTPS 快**，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所共12 个包。（补充：SSL握手https://razeencheng.com/post/ssl-handshake-detail）

\* http 和 https 使用完全不同的连接方式，http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议。端口也不一样，前者是 80，后者是 443。

\* HTTPS 建构在 SSL/TLS 之上的 HTTP 协议，更耗费服务器资源。

**https传输的具体过程**

https://juejin.im/entry/58d7635e5c497d0057fae036

**HTTPS协议的主要作用可以分为两种：一是建立一个信息安全通道，保证数据传输安全；另一种是确认网站的真实性。**

TLS 的完整过程需要三个算法（协议），密钥交互算法，对称加密算法，和消息认证算法

**HTTPS 的整体过程分为证书验证和数据传输阶段**

证书验证阶段：

- 浏览器发起 HTTPS 请求。（ TLS 握手请求）
- 服务端返回 证书(包含服务器公钥S_PuKey)、对称加密算法种类及其他相关信息。
- 客户端验证证书是否合法，不合法提示告警。

数据传输阶段：

- 当证书验证合法后，在本地生成随机数。
- 通过公钥加密随机数，并把加密后的随机数传输到服务端。
- 服务端通过私钥对随机数进行解密。
- 服务端通过客户端传入的随机数构造对称加密算法，之后的数据交互通过对称加密算法进行加解密。（对称加密(也叫私钥加密)指加密和解密使用相同密钥的加密算法）

服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，在此过程中，中间方无法对其解密（即使是客户端也无法解密，因为只有服务器端拥有唯一的私钥），保证了对称秘钥在收发过程中的安全，此时，服务器端和客户端拥有了一套完全相同的对称秘钥。

 常见问题 https://netsecurity.51cto.com/art/201912/607179.htm

**为什么<u>数据传输</u>是用对称加密?**

HTTP的应用场景中通常端与端之间存在大量的交互，非对称加密的加解密效率非常低 

另外，在 HTTPS的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密

Q：HTTPS 的传输过程是怎样的?

A：客户端发起 HTTPS 请求，服务端返回证书，客户端对证书进行验证，验证通过后本地生成用于构造对称加密算法的随机数。

**通过证书中的公钥对随机数进行加密传输到服务端（随机对称密钥），服务端接收后通过私钥解密得到随机对称密钥，之后的数据交互通过对称加密算法进行加解密。**（既有对称加密，也有非对称加密）

Q：为什么需要证书?

A：防止“中间人”攻击，同时可以为网站提供身份证明。

Q：使用 HTTPS 会被抓包吗?

A：会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。

**https对称和非对称详细**   https://www.jianshu.com/p/918d9f517749

##  POST 提交数据四种方式

*POST 几种请求主要包括 application/x-www-form-urlencoded、 multipart/form-data、 application/json、text/xml 四种*

服务端通常是根据请求头（Request Headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。

POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。




## 简述所有状态码 

https://mp.weixin.qq.com/s?__biz=MzA4MjkxMzMyNg==&mid=2654068952&idx=1&sn=1bd63a71610d73fcd563888d6f93398d&scene=24&srcid=0804843QrwLCsKWGYxfPum2H#wechat_redirect

客户端发送一个HTTP请求到服务器的请求消息包括以下格式：

请求行（request line）、请求头部（header）、空行和请求数据 四个部分组成。

网页应用在接收和解释请求消息后服务器会返回一个HTTP响应消息，而HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文

格式如：HTTP-Version Status-Code Reason-Phrase CRLF

其中，HTTP-Version 表示服务器HTTP协议的版本;Status-Code 表示服务器发回的响应状态代码;Reason-Phrase 表示状态代码的文本描述。

而状态码由3个数字组成，第一个数字定义的是响应的类别，有5种可能取值：

1XX信息性状态码（Informational）服务器正在处理请求

2XX成功状态码（Success）请求已正常处理完

3XX重定向状态码（Redirection）需要进行额外操作以完成请求

4XX客户端错误状态码（Client Error）客户端原因导致服务器无法处理请求

5XX服务器错误状态码（Server Error）服务器原因导致处理请求出错

 

常见状态代码、状态描述及说明：

200 OK ：客户端请求成功

204 No Content  表示请求已成功处理，但是没有内容返回（就应该没有内容返回的状况）

206 Partial Content  表示服务器已经完成了部分GET请求

**301** Moved Permanently  永久重定向，请求的资源已经永久的搬到了其他位置

**302** Found 临时重定向，表示请求的资源临时搬到了其他位置。由于重定向是临时发生的，所以客户端在之后的请求中还应该使用原本的 URI。

   由于**历史原因**，用户代理可能会在重定向后的请求中把 POST 方法改为 GET 方法。如果不想这样，应该使用 307（Temporary Redirect） 状态码。

https://zhuanlan.zhihu.com/p/60669395  303,303,307的联系

303 表示服务器要将浏览器重定向到另一个资源，这个资源的 URI 会被写在响应 Header 的 Location 字段。从语义上讲，重定向到的资源并不是你所请求的资源，而是对你所请求资源的一些描述。303 常用于将 POST 请求重定向到 GET 请求，比如你上传了一份个人信息，服务器发回一个 303 响应，将你导向一个“上传成功”页面。

不管原请求是什么方法，重定向请求的方法都是 GET（或 HEAD，不常用）。

304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。（服务端已经执行了GET，但文件未变化。）

307 的定义实际上和 302 是一致的，唯一区别：307 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上。

400 Bad Request 客户端请求有语法错误，不能被服务器所理解

401 Unauthorized 表示发送的请求需要有HTTP认证信息或者是认证失败了（请求未经授权）

403 Forbidden  表示对请求资源的访问被服务器拒绝了

404 Not Found 表示服务器找不到你请求的资源

500 Internal Server Error 表示服务器执行请求的时候出错了

502   网关错误  作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个**无效的响应**  

503 Service Unavailable 表示服务器超负载或正停机维护，无法处理请求，一段时间后可能恢复正常

504      充当网关或代理的服务器，**未及时从远端服务器获取请求**。  实际上504很少会遇到，通常这个错误是由于nginx配置不当引起的，比如你将你的nginx的超时时间设置为300，那么如果此次请求的响应时间超过了300，你就会看到504这个报错。

通俗的来说，nginx作为一个代理服务器，将请求转发到其他服务器或者php-cgi来处理，当nginx收到了无法理解的响应时，就返回502。当nginx超过自己配置的超时时间还没有收到请求时，就返回504错误。从网络角度，502已经与后端建立了连接，但超时；504与后端连接未建立，超时





## 路由器

路由器是连接两个或多个网络的硬件设备，在网络间起[网关](https://baike.baidu.com/item/网关/98992)的作用，是读取每一个数据包中的地址然后决定如何传送的专用智能性的网络设备。

路由器可以分析各种不同类型网络传来的数据包的目的地址，把非TCP/IP网络的地址转换成TCP/IP地址，或者反之；再根据选定的[路由算法](https://baike.baidu.com/item/路由算法/2709757)把各数据包按最佳路线传送到指定位置。所以路由器可以把非TCP/ IP网络连接到[因特网](https://baike.baidu.com/item/因特网/114119)上。



# 操作系统

## 进程线程区别

进程是运行中的程序，线程是进程的内部的一个执行序列

**进程是资源分配的最小单位，线程是CPU调度的最小单位**

进程间切换代价大，线程间切换代价小

进程拥有资源多，线程拥有资源少

多个线程共享进程的资源

- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）

### 进程间通信

**管道**：

​	匿名管道和命名管道

**消息队列**

**共享内存**

**信号量**

​	本质就是一个计数器，用来实现进程之间的互斥与同步

**Socket**

​	这个就是我们一直在用的进程间的通信方式了，如我们的微信APP跟微信服务器通信，其实就是使用的Socket套接字进行通信的。

## CPU调度算法

![img](https://img-blog.csdn.net/20180104165256397?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjkyODc5NzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### cpu内存管理

传统上：

​	连续分配

​	非连续分配：分页，分段

虚拟内存：

​	基于局部性原理，将程序的一部分装入内存，其余部分留在外存，便可启动程序执行。执行过程中内存没有的再调入内存，然后继续执行程序。  另一方面，操作系统将内存中暂时不用的内容换出 到外存上（腾出空间）       显得系统好像提供了一个比实际内存大得多的存储器，称为虚拟存储器。

## Linux

**VM**

*虚拟机*,   指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。

1安装VMware和centOS      2安装Xshell

3. Linx下安装并测试JDK,tomcat,Mysql        4. 部署项目  传war包



**安装VMware**

​	VMware Workstation允许一台真实的电脑在一个[操作系统](https://zh.wikipedia.org/wiki/作業系統)中同时开启并运行数个操作系统，其它VMware产品帮助在多个宿主电脑之间管理或移植VMware虚拟机。

![image-20200704144944237](C:\Users\sprina\AppData\Roaming\Typora\typora-user-images\image-20200704144944237.png)

**安装centOS**

​	Linux发行版之一

![image-20200704145018174](C:\Users\sprina\AppData\Roaming\Typora\typora-user-images\image-20200704145018174.png)

![image-20200704145027539](C:\Users\sprina\AppData\Roaming\Typora\typora-user-images\image-20200704145027539.png)

**安装XShell终端**(远程操控)

Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。**可以非常方便的对linux主机进行远程管理**

​	进入Xshell的界面之后连接上Linux服务器

​	**ls命令**: 显示有哪些文件

![img](https://img-blog.csdn.net/20170212222411839?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzA1ODYxOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

我们已经知道文件有哪些后需要知道如何进入我们想要进入的文件，在windows这种图形化的系统下我们可以使用双击这种方式打开我们需要打开的文件，在Xshell中我们需要使用的是：**cd 命令**，默认是在根节点root下面：

　　需要进入的是usr文件的local文件使用：cd /usr/local，来进入，这个时候我们就显示已经进入了local这个文件下面，需要注意的是在root根目录下进入其他文件时需要在最前面加上斜线“/”，在其他任何二级甚至多级目录下都是可以不加直接进入的。

　　有进入同样就有返回，需要返回的时候我们需要使用：cd ../ 这个命令，同样我们也可以在../之后加上我们需要进入的上级文件目录就可以直接进入了



　　在接下来就是如何编辑文件和查看文件了，假如现在local目录下存在host.xml文件，我们需要编辑或者查看它。**查看的命令是cat host.xml**；**编辑的命令是vi host.xml**，然后按下i，进入修改模式，要不然就只是看，如果我们突然不想修改时，按下ESC 然后在命令行中写下 :q!   然后回车就接触编辑，如果我们是编辑完了需要保存，也需要按下ESC，然后输入 :wq 回车。

　　**总结一下就是：编辑文件 vi，按下i进行编辑   保存结束编辑 ESC :wq 回车   不保存结束编辑 ESC :q! 回车**

![img](https://img-blog.csdn.net/20170212223449713?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzA1ODYxOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

　　在Linux系统下执行文件我们需要使用的的 ./文件名.sh，假如我们需要执行host.sh文件，我们需要进入文件所在目录接着执行即可

**安装   jdk   Tomcat   mysql**

**tomcat 中发布项目**

### Linux终端常用命令

cd 切换目录

pwd      (print work directory)      查看当前所在目录

ls       （list）                   列出当前目录的文件

cat 文件名               显示该文件内的所有内容

 rm    删除    

mv    移动和重命名文件

cp     复制文件

vim   编辑文件 （linux中的编辑器）

​	：wq,即write and quit,此种退出方法=保存并退出



**本地文件上传到Linux服务器：**

​	scp命令

**xshell软件里的xftp程序：**

​		点击xshell软件上的xftp图标（前提xftp已经下载好）  然后就可以互传文件了

一：运行 apt install lrzsz 下载程序

第二步：从Windows上传文件到服务器
运行 rz

弹出文件选择窗口选择文件等待上传完成

第三步：从服务器下载文件到Windows服务器
运行 sz 【your file name】

弹出文件选择窗口选择要下载到的路径即可

## Git

git init  重要   第一次使用git，配置用户信息

配置用户名：git config --global user.name "your name";
配置邮箱：git config --global user.email "youremail@github.com";

git remote add origin https://gitee.com/tianjingang/server.git//将本地与远程关联

从远程git仓库复制项目：git clone 仓库地址

创建新分支 git checkout -b <branchName>

git branch 查看本地
git branch -r 查看远程分支
git branch -a 查看本地和远程分支

提交代码：
   git pull 					拉取分支与本地对比
   git add .     				提交工作区所有文件到暂存区
   git commit -am " "    将暂存区中的文件提交到本地仓库中
   git push origin master      

注意：

​	*git commit --amend*    提交过代码之后，发现一个地方改错了，你下次提交时不想保留上一次的记录；或者你上一次的commit message的描述有误，这时候你可以使用接下来的这个命令：git commit --amend。

提供了最后一次commit的反悔。但是**对于历史提交呢，就必须使用rebase了**。

**修改commit详细** https://blog.csdn.net/ds_Yang/article/details/106599538  

  git pull命令之后git如上报错，解决步骤，可以不管(直接下面3,4步)：

//1.按键盘字母 i 进入insert模式

//2.修改最上面那行黄色合并信息,可以不修改

//3.按键盘左上角"Esc"

//4.输入":wq",注意是冒号+wq,按回车键即可

拉取远程分支（同步远程代码）
git fetch upstream 		  拉取仓库下所有分支：
 git checkout master       git merge upstream/master   把上游的远程代码合并到本地的 master分支 
本地master就同步到最新版了。 git push 推到远程



git log之后，可以看到你之前提交过的git历史：

![img](https://pic1.zhimg.com/80/v2-0d0a335a3a87091c40ce138b8be1a9f0_1440w.jpg)

### Git-Rebase

https://juejin.cn/post/6844903600976576519**

https://cloud.tencent.com/developer/news/231201

https://www.cnblogs.com/kidsitcn/p/5339382.html

**Rebase 场景一：合并多次提交纪录**

​	合并最近的 4 次提交纪录，执行：

```
git rebase -i HEAD~4
```

**Rebase 场景二：让分支合并记录变简洁**

​	`merge` 的信息污染了 `commit` 记录，想要保持一份干净的 `commit`，怎么办呢？这时候，`git rebase` 就派上用场了。

## Node.js

https://www.nodebeginner.org/index-zh-cn.html

JavaScript最早是运行在浏览器中

Node.js事实上就是另外一种上下文，它允许在后端（脱离浏览器环境）运行JavaScript代码。**是 V8 引擎解析的**

要实现在后台运行JavaScript代码，代码需要先被解释然后正确的执行。Node.js的原理正是如此，它使用了Google的V8虚拟机（Google的Chrome浏览器使用的JavaScript执行环境），来解释和执行JavaScript代码。

除此之外，伴随着Node.js的还有许多有用的模块，它们可以简化很多重复的劳作，比如向终端输出字符串。

因此，Node.js事实上既是一个运行时环境，同时又是一个库。

使用Node.js时，我们不仅仅在实现一个应用，同时还实现了整个**HTTP服务器**

## 数据库

### 事务的ACID特性

- Atomicity（原子性）：一个事务中的所有操作，或者全部完成，或者全部不完成,不可分割。事务在执行过程中发生错误，会被[回滚](https://zh.wikipedia.org/wiki/回滚_(数据管理))（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- Consistency（一致性）：在**事务开始之前和事务结束以后，数据库的完整性没有被破坏**。这表示写入的资料必须完全符合所有的预设[约束](https://zh.wikipedia.org/wiki/数据完整性)、[触发器](https://zh.wikipedia.org/wiki/触发器_(数据库))、[级联回滚](https://zh.wikipedia.org/wiki/级联回滚)等。[[1\]](https://zh.wikipedia.org/wiki/ACID#cite_note-acid-1)
- Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性**可以防止多个事务并发执行时由于交叉执行而导致数据的不一致**。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失

### 数据库的索引

https://juejin.im/post/5e6509fd518825490d1267eb

Hash、B+

## react native

